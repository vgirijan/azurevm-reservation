import * as coreAuth from '@azure/core-auth';
import * as coreClient from '@azure/core-client';
import { OperationState } from '@azure/core-lro';
import { PagedAsyncIterableIterator } from '@azure/core-paging';
import { SimplePollerLike } from '@azure/core-lro';

/** Paginated list of applied reservations */
export declare interface AppliedReservationList {
    value?: string[];
    /** Url to get the next page of reservations */
    nextLink?: string;
}

/** The response for applied reservations api */
export declare interface AppliedReservations {
    /**
     * Identifier of the applied reservations
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly id?: string;
    /**
     * Name of resource
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly name?: string;
    /**
     * Type of resource. "Microsoft.Capacity/AppliedReservations"
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly type?: string;
    /** Paginated list of applied reservations */
    reservationOrderIds?: AppliedReservationList;
}

/** Properties specific to applied scope type. Not required if not applicable. Required and need to provide tenantId and managementGroupId if AppliedScopeType is ManagementGroup */
export declare interface AppliedScopeProperties {
    /** Tenant ID where the savings plan should apply benefit. */
    tenantId?: string;
    /** Fully-qualified identifier of the management group where the benefit must be applied. */
    managementGroupId?: string;
    /** Fully-qualified identifier of the subscription. */
    subscriptionId?: string;
    /** Fully-qualified identifier of the resource group. */
    resourceGroupId?: string;
    /** Display name */
    displayName?: string;
}

/**
 * Defines values for AppliedScopeType. \
 * {@link KnownAppliedScopeType} can be used interchangeably with AppliedScopeType,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **Single** \
 * **Shared** \
 * **ManagementGroup**
 */
export declare type AppliedScopeType = string;

/** The response of available scope api containing scopes and their eligibilities. */
export declare interface AvailableScopeProperties {
    /** The scopes checked by the available scope api. */
    properties?: SubscriptionScopeProperties;
}

/** Available scope */
export declare interface AvailableScopeRequest {
    /** Available scope request properties */
    properties?: AvailableScopeRequestProperties;
}

/** Available scope request properties */
export declare interface AvailableScopeRequestProperties {
    scopes?: string[];
}

export declare class AzureReservationAPI extends coreClient.ServiceClient {
    $host: string;
    /**
     * Initializes a new instance of the AzureReservationAPI class.
     * @param credentials Subscription credentials which uniquely identify client subscription.
     * @param options The parameter options
     */
    constructor(credentials: coreAuth.TokenCredential, options?: AzureReservationAPIOptionalParams);
    /**
     * Get the regions and skus that are available for RI purchase for the specified Azure subscription.
     * @param subscriptionId Id of the subscription
     * @param options The options parameters.
     */
    listCatalog(subscriptionId: string, options?: GetCatalogOptionalParams): PagedAsyncIterableIterator<Catalog>;
    private getCatalogPagingPage;
    private getCatalogPagingAll;
    /**
     * Get the regions and skus that are available for RI purchase for the specified Azure subscription.
     * @param subscriptionId Id of the subscription
     * @param options The options parameters.
     */
    private _getCatalog;
    /**
     * Get applicable `Reservation`s that are applied to this subscription or a resource group under this
     * subscription.
     * @param subscriptionId Id of the subscription
     * @param options The options parameters.
     */
    getAppliedReservationList(subscriptionId: string, options?: GetAppliedReservationListOptionalParams): Promise<GetAppliedReservationListResponse>;
    /**
     * GetCatalogNext
     * @param subscriptionId Id of the subscription
     * @param nextLink The nextLink from the previous successful call to the GetCatalog method.
     * @param options The options parameters.
     */
    private _getCatalogNext;
    reservation: Reservation;
    reservationOrder: ReservationOrder;
    operation: Operation;
    calculateRefund: CalculateRefund;
    return: Return;
    calculateExchange: CalculateExchange;
    exchange: Exchange;
    quota: Quota;
    quotaRequestStatus: QuotaRequestStatus;
}

/** Optional parameters. */
export declare interface AzureReservationAPIOptionalParams extends coreClient.ServiceClientOptions {
    /** server parameter */
    $host?: string;
    /** Overrides client endpoint. */
    endpoint?: string;
}

/** billing information */
export declare interface BillingInformation {
    /** Pricing information containing the amount and the currency code */
    billingCurrencyTotalPaidAmount?: Price;
    /** Pricing information containing the amount and the currency code */
    billingCurrencyProratedAmount?: Price;
    /** Pricing information containing the amount and the currency code */
    billingCurrencyRemainingCommitmentAmount?: Price;
}

/**
 * Defines values for BillingPlan. \
 * {@link KnownBillingPlan} can be used interchangeably with BillingPlan,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **P1M**
 */
export declare type BillingPlan = string;

/** Interface representing a CalculateExchange. */
export declare interface CalculateExchange {
    /**
     * Calculates price for exchanging `Reservations` if there are no policy errors.
     *
     * @param body Request containing purchases and refunds that need to be executed.
     * @param options The options parameters.
     */
    beginPost(body: CalculateExchangeRequest, options?: CalculateExchangePostOptionalParams): Promise<SimplePollerLike<OperationState<CalculateExchangePostResponse>, CalculateExchangePostResponse>>;
    /**
     * Calculates price for exchanging `Reservations` if there are no policy errors.
     *
     * @param body Request containing purchases and refunds that need to be executed.
     * @param options The options parameters.
     */
    beginPostAndWait(body: CalculateExchangeRequest, options?: CalculateExchangePostOptionalParams): Promise<CalculateExchangePostResponse>;
}

/** CalculateExchange operation result */
export declare interface CalculateExchangeOperationResultResponse {
    /** It should match what is used to GET the operation result. */
    id?: string;
    /** It must match the last segment of the id field, and will typically be a GUID / system generated value. */
    name?: string;
    /** Status of the operation. */
    status?: CalculateExchangeOperationResultStatus;
    /** CalculateExchange response properties */
    properties?: CalculateExchangeResponseProperties;
    /** Required if status == failed or status == canceled. */
    error?: OperationResultError;
}

/**
 * Defines values for CalculateExchangeOperationResultStatus. \
 * {@link KnownCalculateExchangeOperationResultStatus} can be used interchangeably with CalculateExchangeOperationResultStatus,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **Succeeded** \
 * **Failed** \
 * **Cancelled** \
 * **Pending**
 */
export declare type CalculateExchangeOperationResultStatus = string;

/** Defines headers for CalculateExchange_post operation. */
export declare interface CalculateExchangePostHeaders {
    /** URL for checking the ongoing status of the operation. */
    azureAsyncOperation?: string;
    /** URL for determining when an operation has completed. Only use this value only when Azure-AsyncOperation isn't returned. */
    location?: string;
    /** Clients should wait for the Retry-After interval before polling again */
    retryAfter?: number;
}

/** Optional parameters. */
export declare interface CalculateExchangePostOptionalParams extends coreClient.OperationOptions {
    /** Delay to wait until next poll, in milliseconds. */
    updateIntervalInMs?: number;
    /** A serialized poller which can be used to resume an existing paused Long-Running-Operation. */
    resumeFrom?: string;
}

/** Contains response data for the post operation. */
export declare type CalculateExchangePostResponse = CalculateExchangeOperationResultResponse;

/** Calculate exchange request */
export declare interface CalculateExchangeRequest {
    /** Calculate exchange request properties */
    properties?: CalculateExchangeRequestProperties;
}

/** Calculate exchange request properties */
export declare interface CalculateExchangeRequestProperties {
    /** List of reservations that are being purchased in this exchange. */
    reservationsToPurchase?: PurchaseRequest[];
    /** List of savings plans that are being purchased in this exchange. */
    savingsPlansToPurchase?: SavingsPlanPurchaseRequest[];
    /** List of reservations that are being returned in this exchange. */
    reservationsToExchange?: ReservationToReturn[];
}

/** CalculateExchange response properties */
export declare interface CalculateExchangeResponseProperties {
    /** Exchange session identifier */
    sessionId?: string;
    /** Pricing information containing the amount and the currency code */
    netPayable?: Price;
    /** Pricing information containing the amount and the currency code */
    refundsTotal?: Price;
    /** Pricing information containing the amount and the currency code */
    purchasesTotal?: Price;
    /** Details of the reservations being purchased */
    reservationsToPurchase?: ReservationToPurchaseCalculateExchange[];
    /** Details of the savings plans being purchased */
    savingsPlansToPurchase?: SavingsPlanToPurchaseCalculateExchange[];
    /** Details of the reservations being returned */
    reservationsToExchange?: ReservationToExchange[];
    /** Exchange policy errors */
    policyResult?: ExchangePolicyErrors;
}

/** The response of calculate price for reservation. */
export declare interface CalculatePriceResponse {
    /** Properties for calculate price response */
    properties?: CalculatePriceResponseProperties;
}

/** Properties for calculate price response */
export declare interface CalculatePriceResponseProperties {
    /** Currency and amount that customer will be charged in customer's local currency. Tax is not included. */
    billingCurrencyTotal?: CalculatePriceResponsePropertiesBillingCurrencyTotal;
    /** Net total amount in pricing currency. */
    netTotal?: number;
    /** Tax amount in pricing currency. */
    taxTotal?: number;
    /** Total amount in pricing currency. */
    grandTotal?: number;
    /** Whether or not tax is included in grand total */
    isTaxIncluded?: boolean;
    /** True if billing is managed by Microsoft Partner. Used only for CSP accounts. */
    isBillingPartnerManaged?: boolean;
    /** GUID that represents reservation order that can be placed after calculating price. */
    reservationOrderId?: string;
    /** Title of sku that is being purchased. */
    skuTitle?: string;
    /** Description of sku that is being purchased. */
    skuDescription?: string;
    /** Amount that Microsoft uses for record. Used during refund for calculating refund limit. Tax is not included. */
    pricingCurrencyTotal?: CalculatePriceResponsePropertiesPricingCurrencyTotal;
    paymentSchedule?: PaymentDetail[];
}

/** Currency and amount that customer will be charged in customer's local currency. Tax is not included. */
export declare interface CalculatePriceResponsePropertiesBillingCurrencyTotal {
    /** The ISO 4217 3-letter currency code for the currency used by this purchase record. */
    currencyCode?: string;
    /** Amount in pricing currency. Tax is not included. */
    amount?: number;
}

/** Amount that Microsoft uses for record. Used during refund for calculating refund limit. Tax is not included. */
export declare interface CalculatePriceResponsePropertiesPricingCurrencyTotal {
    /** The ISO 4217 3-letter currency code for the currency used by this purchase record. */
    currencyCode?: string;
    amount?: number;
}

/** Interface representing a CalculateRefund. */
export declare interface CalculateRefund {
    /**
     * Calculate price for returning `Reservations` if there are no policy errors.
     *
     * @param reservationOrderId Order Id of the reservation
     * @param body Information needed for calculating refund of a reservation.
     * @param options The options parameters.
     */
    post(reservationOrderId: string, body: CalculateRefundRequest, options?: CalculateRefundPostOptionalParams): Promise<CalculateRefundPostResponse>;
}

/** Optional parameters. */
export declare interface CalculateRefundPostOptionalParams extends coreClient.OperationOptions {
}

/** Contains response data for the post operation. */
export declare type CalculateRefundPostResponse = CalculateRefundResponse;

/** Request containing information needed for calculating refund. */
export declare interface CalculateRefundRequest {
    /** Fully qualified identifier of the reservation order being returned */
    id?: string;
    /** Properties needed for calculate refund including the scope and the reservation to be returned. */
    properties?: CalculateRefundRequestProperties;
}

/** Properties needed for calculate refund including the scope and the reservation to be returned. */
export declare interface CalculateRefundRequestProperties {
    /** The scope of the refund, e.g. Reservation */
    scope?: string;
    /** Reservation to return */
    reservationToReturn?: ReservationToReturn;
}

/** The response of calculate refund containing refund information of reservation */
export declare interface CalculateRefundResponse {
    /** Fully qualified identifier of the reservation being returned */
    id?: string;
    /** The refund properties of reservation */
    properties?: RefundResponseProperties;
}

/** Product details of a type of resource. */
export declare interface Catalog {
    /**
     * The type of resource the sku applies to.
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly resourceType?: string;
    /**
     * The name of sku
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly name?: string;
    /** The billing plan options available for this sku. */
    billingPlans?: {
        [propertyName: string]: ReservationBillingPlan[];
    };
    /**
     * Available reservation terms for this resource
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly terms?: ReservationTerm[];
    /** NOTE: This property will not be serialized. It can only be populated by the server. */
    readonly locations?: string[];
    /** NOTE: This property will not be serialized. It can only be populated by the server. */
    readonly skuProperties?: SkuProperty[];
    /**
     * Pricing information about the sku
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly msrp?: CatalogMsrp;
    /** NOTE: This property will not be serialized. It can only be populated by the server. */
    readonly restrictions?: SkuRestriction[];
    /**
     * The tier of this sku
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly tier?: string;
    /**
     * The size of this sku
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly size?: string;
    /** NOTE: This property will not be serialized. It can only be populated by the server. */
    readonly capabilities?: SkuCapability[];
}

/** Pricing information about the sku */
export declare interface CatalogMsrp {
    /** Amount in pricing currency. Tax not included. */
    p1Y?: Price;
    /** Amount in pricing currency. Tax not included. */
    p3Y?: Price;
    /** Amount in pricing currency. Tax not included. */
    p5Y?: Price;
}

/** The list of catalogs and pagination information. */
export declare interface CatalogsResult {
    /**
     * The list of catalogs.
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly value?: Catalog[];
    /**
     * The link (url) to the next page of results.
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly nextLink?: string;
    /** The total amount of catalog items. */
    totalItems?: number;
}

/** Request body for change directory of a reservation. */
export declare interface ChangeDirectoryRequest {
    /** Tenant id GUID that reservation order is to be transferred to */
    destinationTenantId?: string;
}

/** Change directory response */
export declare interface ChangeDirectoryResponse {
    /** Change directory result for reservation order or reservation */
    reservationOrder?: ChangeDirectoryResult;
    reservations?: ChangeDirectoryResult[];
}

/** Change directory result for reservation order or reservation */
export declare interface ChangeDirectoryResult {
    /** Identifier of the reservation order or reservation */
    id?: string;
    /** Name of the reservation order or reservation */
    name?: string;
    /** True if change directory operation succeeded on this reservation order or reservation */
    isSucceeded?: boolean;
    /** Error reason if operation failed. Null otherwise */
    error?: string;
}

/** Commitment towards the benefit. */
export declare interface Commitment extends Price {
    /** Commitment grain. */
    grain?: CommitmentGrain;
}

/**
 * Defines values for CommitmentGrain. \
 * {@link KnownCommitmentGrain} can be used interchangeably with CommitmentGrain,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **Hourly**
 */
export declare type CommitmentGrain = string;

/**
 * Defines values for CreatedByType. \
 * {@link KnownCreatedByType} can be used interchangeably with CreatedByType,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **User** \
 * **Application** \
 * **ManagedIdentity** \
 * **Key**
 */
export declare type CreatedByType = string;

/** Quota change requests information. */
export declare interface CreateGenericQuotaRequestParameters {
    /** Quota change requests. */
    value?: CurrentQuotaLimitBase[];
}

/** Current quota limits. */
export declare interface CurrentQuotaLimit {
    /**
     * The details of the quota request status.
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly provisioningState?: QuotaRequestState;
    /**
     * A user friendly message.
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly message?: string;
    /**
     * The quota request ID.
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly id?: string;
    /**
     * The name of the quota request.
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly name?: string;
    /**
     * Type of resource. "Microsoft.Capacity/ServiceLimits"
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly type?: string;
    /** Quota properties for the resource. */
    properties?: QuotaProperties;
}

/** Quota properties. */
export declare interface CurrentQuotaLimitBase {
    /**
     * The quota request ID.
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly id?: string;
    /**
     * The name of the quota request.
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly name?: string;
    /**
     * Type of resource. "Microsoft.Capacity/ServiceLimits"
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly type?: string;
    /** Quota properties for the resource. */
    properties?: QuotaProperties;
}

/**
 * Defines values for DisplayProvisioningState. \
 * {@link KnownDisplayProvisioningState} can be used interchangeably with DisplayProvisioningState,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **Succeeded** \
 * **Expiring** \
 * **Expired** \
 * **Pending** \
 * **Processing** \
 * **Cancelled** \
 * **Failed** \
 * **Warning** \
 * **NoBenefit**
 */
export declare type DisplayProvisioningState = string;

/** The details of the error. */
export declare interface ErrorDetails {
    /**
     * Error code.
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly code?: string;
    /**
     * Error message indicating why the operation failed.
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly message?: string;
    /**
     * The target of the particular error.
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly target?: string;
}

/** Error information */
export declare interface ErrorModel {
    /** Extended error information including error code and error message */
    error?: ExtendedErrorInfo;
}

/** Error response indicates that the service is not able to process the incoming request. The reason is provided in the error message. */
export declare interface ErrorResponse {
    /** The details of the error. */
    error?: ErrorDetails;
}

/**
 * Defines values for ErrorResponseCode. \
 * {@link KnownErrorResponseCode} can be used interchangeably with ErrorResponseCode,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **NotSpecified** \
 * **InternalServerError** \
 * **ServerTimeout** \
 * **AuthorizationFailed** \
 * **BadRequest** \
 * **ClientCertificateThumbprintNotSet** \
 * **InvalidRequestContent** \
 * **OperationFailed** \
 * **HttpMethodNotSupported** \
 * **InvalidRequestUri** \
 * **MissingTenantId** \
 * **InvalidTenantId** \
 * **InvalidReservationOrderId** \
 * **InvalidReservationId** \
 * **ReservationIdNotInReservationOrder** \
 * **ReservationOrderNotFound** \
 * **InvalidSubscriptionId** \
 * **InvalidAccessToken** \
 * **InvalidLocationId** \
 * **UnauthenticatedRequestsThrottled** \
 * **InvalidHealthCheckType** \
 * **Forbidden** \
 * **BillingScopeIdCannotBeChanged** \
 * **AppliedScopesNotAssociatedWithCommerceAccount** \
 * **PatchValuesSameAsExisting** \
 * **RoleAssignmentCreationFailed** \
 * **ReservationOrderCreationFailed** \
 * **ReservationOrderNotEnabled** \
 * **CapacityUpdateScopesFailed** \
 * **UnsupportedReservationTerm** \
 * **ReservationOrderIdAlreadyExists** \
 * **RiskCheckFailed** \
 * **CreateQuoteFailed** \
 * **ActivateQuoteFailed** \
 * **NonsupportedAccountId** \
 * **PaymentInstrumentNotFound** \
 * **MissingAppliedScopesForSingle** \
 * **NoValidReservationsToReRate** \
 * **ReRateOnlyAllowedForEA** \
 * **OperationCannotBePerformedInCurrentState** \
 * **InvalidSingleAppliedScopesCount** \
 * **InvalidFulfillmentRequestParameters** \
 * **NotSupportedCountry** \
 * **InvalidRefundQuantity** \
 * **PurchaseError** \
 * **BillingCustomerInputError** \
 * **BillingPaymentInstrumentSoftError** \
 * **BillingPaymentInstrumentHardError** \
 * **BillingTransientError** \
 * **BillingError** \
 * **FulfillmentConfigurationError** \
 * **FulfillmentOutOfStockError** \
 * **FulfillmentTransientError** \
 * **FulfillmentError** \
 * **CalculatePriceFailed** \
 * **AppliedScopesSameAsExisting** \
 * **SelfServiceRefundNotSupported** \
 * **RefundLimitExceeded**
 */
export declare type ErrorResponseCode = string;

/** The API error. */
export declare interface ExceptionResponse {
    /** The API error details. */
    error?: ServiceError;
}

/** Interface representing a Exchange. */
export declare interface Exchange {
    /**
     * Returns one or more `Reservations` in exchange for one or more `Reservation` purchases.
     *
     * @param body Request containing the refunds and purchases that need to be executed.
     * @param options The options parameters.
     */
    beginPost(body: ExchangeRequest, options?: ExchangePostOptionalParams): Promise<SimplePollerLike<OperationState<ExchangePostResponse>, ExchangePostResponse>>;
    /**
     * Returns one or more `Reservations` in exchange for one or more `Reservation` purchases.
     *
     * @param body Request containing the refunds and purchases that need to be executed.
     * @param options The options parameters.
     */
    beginPostAndWait(body: ExchangeRequest, options?: ExchangePostOptionalParams): Promise<ExchangePostResponse>;
}

/** Exchange operation result */
export declare interface ExchangeOperationResultResponse {
    /** It should match what is used to GET the operation result. */
    id?: string;
    /** It must match the last segment of the id field, and will typically be a GUID / system generated value. */
    name?: string;
    /** Status of the operation. */
    status?: ExchangeOperationResultStatus;
    /** Exchange response properties */
    properties?: ExchangeResponseProperties;
    /** Required if status == failed or status == canceled. */
    error?: OperationResultError;
}

/**
 * Defines values for ExchangeOperationResultStatus. \
 * {@link KnownExchangeOperationResultStatus} can be used interchangeably with ExchangeOperationResultStatus,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **Succeeded** \
 * **Failed** \
 * **Cancelled** \
 * **PendingRefunds** \
 * **PendingPurchases**
 */
export declare type ExchangeOperationResultStatus = string;

/** error details */
export declare interface ExchangePolicyError {
    code?: string;
    message?: string;
}

/** Exchange policy errors */
export declare interface ExchangePolicyErrors {
    /** Exchange Policy errors */
    policyErrors?: ExchangePolicyError[];
}

/** Defines headers for Exchange_post operation. */
export declare interface ExchangePostHeaders {
    /** URL for checking the ongoing status of the operation. */
    azureAsyncOperation?: string;
    /** URL for determining when an operation has completed. Only use this value only when Azure-AsyncOperation isn't returned. */
    location?: string;
    /** Clients should wait for the Retry-After interval before polling again */
    retryAfter?: number;
}

/** Optional parameters. */
export declare interface ExchangePostOptionalParams extends coreClient.OperationOptions {
    /** Delay to wait until next poll, in milliseconds. */
    updateIntervalInMs?: number;
    /** A serialized poller which can be used to resume an existing paused Long-Running-Operation. */
    resumeFrom?: string;
}

/** Contains response data for the post operation. */
export declare type ExchangePostResponse = ExchangeOperationResultResponse;

/** Exchange request */
export declare interface ExchangeRequest {
    /** Exchange request properties */
    properties?: ExchangeRequestProperties;
}

/** Exchange request properties */
export declare interface ExchangeRequestProperties {
    /** SessionId that was returned by CalculateExchange API. */
    sessionId?: string;
}

/** Exchange response properties */
export declare interface ExchangeResponseProperties {
    /** Exchange session identifier */
    sessionId?: string;
    /** Pricing information containing the amount and the currency code */
    netPayable?: Price;
    /** Pricing information containing the amount and the currency code */
    refundsTotal?: Price;
    /** Pricing information containing the amount and the currency code */
    purchasesTotal?: Price;
    /** Details of the reservations being purchased */
    reservationsToPurchase?: ReservationToPurchaseExchange[];
    /** Details of the savings plans being purchased */
    savingsPlansToPurchase?: SavingsPlanToPurchaseExchange[];
    /** Details of the reservations being returned */
    reservationsToExchange?: ReservationToReturnForExchange[];
    /** Exchange policy errors */
    policyResult?: ExchangePolicyErrors;
}

/** Extended error information including error code and error message */
export declare interface ExtendedErrorInfo {
    /** Error code describing the reason that service is not able to process the incoming request */
    code?: ErrorResponseCode;
    message?: string;
}

export declare interface ExtendedStatusInfo {
    statusCode?: ReservationStatusCode;
    /** The message giving detailed information about the status code. */
    message?: string;
}

/** Optional parameters. */
export declare interface GetAppliedReservationListOptionalParams extends coreClient.OperationOptions {
}

/** Contains response data for the getAppliedReservationList operation. */
export declare type GetAppliedReservationListResponse = AppliedReservations;

/** Optional parameters. */
export declare interface GetCatalogNextOptionalParams extends coreClient.OperationOptions {
}

/** Contains response data for the getCatalogNext operation. */
export declare type GetCatalogNextResponse = CatalogsResult;

/** Optional parameters. */
export declare interface GetCatalogOptionalParams extends coreClient.OperationOptions {
    /** May be used to filter by Catalog properties. The filter supports 'eq', 'or', and 'and'. */
    filter?: string;
    /** The type of the resource for which the skus should be provided. */
    reservedResourceType?: string;
    /** Filters the skus based on the location specified in this parameter. This can be an Azure region or global */
    location?: string;
    /** Publisher id used to get the third party products */
    publisherId?: string;
    /** Offer id used to get the third party products */
    offerId?: string;
    /** Plan id used to get the third party products */
    planId?: string;
    /** The number of reservations to skip from the list before returning results */
    skip?: number;
    /** To number of reservations to return */
    take?: number;
}

/** Contains response data for the getCatalog operation. */
export declare type GetCatalogResponse = CatalogsResult;

/**
 * Given the last `.value` produced by the `byPage` iterator,
 * returns a continuation token that can be used to begin paging from
 * that point later.
 * @param page An object from accessing `value` on the IteratorResult from a `byPage` iterator.
 * @returns The continuation token that can be passed into byPage() during future calls.
 */
export declare function getContinuationToken(page: unknown): string | undefined;

/**
 * Defines values for InstanceFlexibility. \
 * {@link KnownInstanceFlexibility} can be used interchangeably with InstanceFlexibility,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **On** \
 * **Off**
 */
export declare type InstanceFlexibility = string;

/** Known values of {@link AppliedScopeType} that the service accepts. */
export declare enum KnownAppliedScopeType {
    /** Single */
    Single = "Single",
    /** Shared */
    Shared = "Shared",
    /** ManagementGroup */
    ManagementGroup = "ManagementGroup"
}

/** Known values of {@link BillingPlan} that the service accepts. */
export declare enum KnownBillingPlan {
    /** P1M */
    P1M = "P1M"
}

/** Known values of {@link CalculateExchangeOperationResultStatus} that the service accepts. */
export declare enum KnownCalculateExchangeOperationResultStatus {
    /** Succeeded */
    Succeeded = "Succeeded",
    /** Failed */
    Failed = "Failed",
    /** Cancelled */
    Cancelled = "Cancelled",
    /** Pending */
    Pending = "Pending"
}

/** Known values of {@link CommitmentGrain} that the service accepts. */
export declare enum KnownCommitmentGrain {
    /** Hourly */
    Hourly = "Hourly"
}

/** Known values of {@link CreatedByType} that the service accepts. */
export declare enum KnownCreatedByType {
    /** User */
    User = "User",
    /** Application */
    Application = "Application",
    /** ManagedIdentity */
    ManagedIdentity = "ManagedIdentity",
    /** Key */
    Key = "Key"
}

/** Known values of {@link DisplayProvisioningState} that the service accepts. */
export declare enum KnownDisplayProvisioningState {
    /** Succeeded */
    Succeeded = "Succeeded",
    /** Expiring */
    Expiring = "Expiring",
    /** Expired */
    Expired = "Expired",
    /** Pending */
    Pending = "Pending",
    /** Processing */
    Processing = "Processing",
    /** Cancelled */
    Cancelled = "Cancelled",
    /** Failed */
    Failed = "Failed",
    /** Warning */
    Warning = "Warning",
    /** NoBenefit */
    NoBenefit = "NoBenefit"
}

/** Known values of {@link ErrorResponseCode} that the service accepts. */
export declare enum KnownErrorResponseCode {
    /** NotSpecified */
    NotSpecified = "NotSpecified",
    /** InternalServerError */
    InternalServerError = "InternalServerError",
    /** ServerTimeout */
    ServerTimeout = "ServerTimeout",
    /** AuthorizationFailed */
    AuthorizationFailed = "AuthorizationFailed",
    /** BadRequest */
    BadRequest = "BadRequest",
    /** ClientCertificateThumbprintNotSet */
    ClientCertificateThumbprintNotSet = "ClientCertificateThumbprintNotSet",
    /** InvalidRequestContent */
    InvalidRequestContent = "InvalidRequestContent",
    /** OperationFailed */
    OperationFailed = "OperationFailed",
    /** HttpMethodNotSupported */
    HttpMethodNotSupported = "HttpMethodNotSupported",
    /** InvalidRequestUri */
    InvalidRequestUri = "InvalidRequestUri",
    /** MissingTenantId */
    MissingTenantId = "MissingTenantId",
    /** InvalidTenantId */
    InvalidTenantId = "InvalidTenantId",
    /** InvalidReservationOrderId */
    InvalidReservationOrderId = "InvalidReservationOrderId",
    /** InvalidReservationId */
    InvalidReservationId = "InvalidReservationId",
    /** ReservationIdNotInReservationOrder */
    ReservationIdNotInReservationOrder = "ReservationIdNotInReservationOrder",
    /** ReservationOrderNotFound */
    ReservationOrderNotFound = "ReservationOrderNotFound",
    /** InvalidSubscriptionId */
    InvalidSubscriptionId = "InvalidSubscriptionId",
    /** InvalidAccessToken */
    InvalidAccessToken = "InvalidAccessToken",
    /** InvalidLocationId */
    InvalidLocationId = "InvalidLocationId",
    /** UnauthenticatedRequestsThrottled */
    UnauthenticatedRequestsThrottled = "UnauthenticatedRequestsThrottled",
    /** InvalidHealthCheckType */
    InvalidHealthCheckType = "InvalidHealthCheckType",
    /** Forbidden */
    Forbidden = "Forbidden",
    /** BillingScopeIdCannotBeChanged */
    BillingScopeIdCannotBeChanged = "BillingScopeIdCannotBeChanged",
    /** AppliedScopesNotAssociatedWithCommerceAccount */
    AppliedScopesNotAssociatedWithCommerceAccount = "AppliedScopesNotAssociatedWithCommerceAccount",
    /** PatchValuesSameAsExisting */
    PatchValuesSameAsExisting = "PatchValuesSameAsExisting",
    /** RoleAssignmentCreationFailed */
    RoleAssignmentCreationFailed = "RoleAssignmentCreationFailed",
    /** ReservationOrderCreationFailed */
    ReservationOrderCreationFailed = "ReservationOrderCreationFailed",
    /** ReservationOrderNotEnabled */
    ReservationOrderNotEnabled = "ReservationOrderNotEnabled",
    /** CapacityUpdateScopesFailed */
    CapacityUpdateScopesFailed = "CapacityUpdateScopesFailed",
    /** UnsupportedReservationTerm */
    UnsupportedReservationTerm = "UnsupportedReservationTerm",
    /** ReservationOrderIdAlreadyExists */
    ReservationOrderIdAlreadyExists = "ReservationOrderIdAlreadyExists",
    /** RiskCheckFailed */
    RiskCheckFailed = "RiskCheckFailed",
    /** CreateQuoteFailed */
    CreateQuoteFailed = "CreateQuoteFailed",
    /** ActivateQuoteFailed */
    ActivateQuoteFailed = "ActivateQuoteFailed",
    /** NonsupportedAccountId */
    NonsupportedAccountId = "NonsupportedAccountId",
    /** PaymentInstrumentNotFound */
    PaymentInstrumentNotFound = "PaymentInstrumentNotFound",
    /** MissingAppliedScopesForSingle */
    MissingAppliedScopesForSingle = "MissingAppliedScopesForSingle",
    /** NoValidReservationsToReRate */
    NoValidReservationsToReRate = "NoValidReservationsToReRate",
    /** ReRateOnlyAllowedForEA */
    ReRateOnlyAllowedForEA = "ReRateOnlyAllowedForEA",
    /** OperationCannotBePerformedInCurrentState */
    OperationCannotBePerformedInCurrentState = "OperationCannotBePerformedInCurrentState",
    /** InvalidSingleAppliedScopesCount */
    InvalidSingleAppliedScopesCount = "InvalidSingleAppliedScopesCount",
    /** InvalidFulfillmentRequestParameters */
    InvalidFulfillmentRequestParameters = "InvalidFulfillmentRequestParameters",
    /** NotSupportedCountry */
    NotSupportedCountry = "NotSupportedCountry",
    /** InvalidRefundQuantity */
    InvalidRefundQuantity = "InvalidRefundQuantity",
    /** PurchaseError */
    PurchaseError = "PurchaseError",
    /** BillingCustomerInputError */
    BillingCustomerInputError = "BillingCustomerInputError",
    /** BillingPaymentInstrumentSoftError */
    BillingPaymentInstrumentSoftError = "BillingPaymentInstrumentSoftError",
    /** BillingPaymentInstrumentHardError */
    BillingPaymentInstrumentHardError = "BillingPaymentInstrumentHardError",
    /** BillingTransientError */
    BillingTransientError = "BillingTransientError",
    /** BillingError */
    BillingError = "BillingError",
    /** FulfillmentConfigurationError */
    FulfillmentConfigurationError = "FulfillmentConfigurationError",
    /** FulfillmentOutOfStockError */
    FulfillmentOutOfStockError = "FulfillmentOutOfStockError",
    /** FulfillmentTransientError */
    FulfillmentTransientError = "FulfillmentTransientError",
    /** FulfillmentError */
    FulfillmentError = "FulfillmentError",
    /** CalculatePriceFailed */
    CalculatePriceFailed = "CalculatePriceFailed",
    /** AppliedScopesSameAsExisting */
    AppliedScopesSameAsExisting = "AppliedScopesSameAsExisting",
    /** SelfServiceRefundNotSupported */
    SelfServiceRefundNotSupported = "SelfServiceRefundNotSupported",
    /** RefundLimitExceeded */
    RefundLimitExceeded = "RefundLimitExceeded"
}

/** Known values of {@link ExchangeOperationResultStatus} that the service accepts. */
export declare enum KnownExchangeOperationResultStatus {
    /** Succeeded */
    Succeeded = "Succeeded",
    /** Failed */
    Failed = "Failed",
    /** Cancelled */
    Cancelled = "Cancelled",
    /** PendingRefunds */
    PendingRefunds = "PendingRefunds",
    /** PendingPurchases */
    PendingPurchases = "PendingPurchases"
}

/** Known values of {@link InstanceFlexibility} that the service accepts. */
export declare enum KnownInstanceFlexibility {
    /** On */
    On = "On",
    /** Off */
    Off = "Off"
}

/** Known values of {@link Location} that the service accepts. */
export declare enum KnownLocation {
    /** Westus */
    Westus = "westus",
    /** Eastus */
    Eastus = "eastus",
    /** Eastus2 */
    Eastus2 = "eastus2",
    /** Northcentralus */
    Northcentralus = "northcentralus",
    /** Westus2 */
    Westus2 = "westus2",
    /** Southcentralus */
    Southcentralus = "southcentralus",
    /** Centralus */
    Centralus = "centralus",
    /** Westeurope */
    Westeurope = "westeurope",
    /** Northeurope */
    Northeurope = "northeurope",
    /** Eastasia */
    Eastasia = "eastasia",
    /** Southeastasia */
    Southeastasia = "southeastasia",
    /** Japaneast */
    Japaneast = "japaneast",
    /** Japanwest */
    Japanwest = "japanwest",
    /** Brazilsouth */
    Brazilsouth = "brazilsouth",
    /** Australiaeast */
    Australiaeast = "australiaeast",
    /** Australiasoutheast */
    Australiasoutheast = "australiasoutheast",
    /** Southindia */
    Southindia = "southindia",
    /** Westindia */
    Westindia = "westindia",
    /** Centralindia */
    Centralindia = "centralindia",
    /** Canadacentral */
    Canadacentral = "canadacentral",
    /** Canadaeast */
    Canadaeast = "canadaeast",
    /** Uksouth */
    Uksouth = "uksouth",
    /** Westcentralus */
    Westcentralus = "westcentralus",
    /** Ukwest */
    Ukwest = "ukwest"
}

/** Known values of {@link OperationStatus} that the service accepts. */
export declare enum KnownOperationStatus {
    /** Succeeded */
    Succeeded = "Succeeded",
    /** Failed */
    Failed = "Failed",
    /** Cancelled */
    Cancelled = "Cancelled",
    /** Pending */
    Pending = "Pending"
}

/** Known values of {@link PaymentStatus} that the service accepts. */
export declare enum KnownPaymentStatus {
    /** Succeeded */
    Succeeded = "Succeeded",
    /** Failed */
    Failed = "Failed",
    /** Scheduled */
    Scheduled = "Scheduled",
    /** Cancelled */
    Cancelled = "Cancelled"
}

/** Known values of {@link ProvisioningState} that the service accepts. */
export declare enum KnownProvisioningState {
    /** Creating */
    Creating = "Creating",
    /** PendingResourceHold */
    PendingResourceHold = "PendingResourceHold",
    /** ConfirmedResourceHold */
    ConfirmedResourceHold = "ConfirmedResourceHold",
    /** PendingBilling */
    PendingBilling = "PendingBilling",
    /** ConfirmedBilling */
    ConfirmedBilling = "ConfirmedBilling",
    /** Created */
    Created = "Created",
    /** Succeeded */
    Succeeded = "Succeeded",
    /** Cancelled */
    Cancelled = "Cancelled",
    /** Expired */
    Expired = "Expired",
    /** BillingFailed */
    BillingFailed = "BillingFailed",
    /** Failed */
    Failed = "Failed",
    /** Split */
    Split = "Split",
    /** Merged */
    Merged = "Merged"
}

/** Known values of {@link QuotaRequestState} that the service accepts. */
export declare enum KnownQuotaRequestState {
    /** Accepted */
    Accepted = "Accepted",
    /** Invalid */
    Invalid = "Invalid",
    /** Succeeded */
    Succeeded = "Succeeded",
    /** Failed */
    Failed = "Failed",
    /** InProgress */
    InProgress = "InProgress"
}

/** Known values of {@link ReservationBillingPlan} that the service accepts. */
export declare enum KnownReservationBillingPlan {
    /** Upfront */
    Upfront = "Upfront",
    /** Monthly */
    Monthly = "Monthly"
}

/** Known values of {@link ReservationStatusCode} that the service accepts. */
export declare enum KnownReservationStatusCode {
    /** None */
    None = "None",
    /** Pending */
    Pending = "Pending",
    /** Processing */
    Processing = "Processing",
    /** Active */
    Active = "Active",
    /** PurchaseError */
    PurchaseError = "PurchaseError",
    /** PaymentInstrumentError */
    PaymentInstrumentError = "PaymentInstrumentError",
    /** Split */
    Split = "Split",
    /** Merged */
    Merged = "Merged",
    /** Expired */
    Expired = "Expired",
    /** Succeeded */
    Succeeded = "Succeeded"
}

/** Known values of {@link ReservationTerm} that the service accepts. */
export declare enum KnownReservationTerm {
    /** P1Y */
    P1Y = "P1Y",
    /** P3Y */
    P3Y = "P3Y",
    /** P5Y */
    P5Y = "P5Y"
}

/** Known values of {@link ReservedResourceType} that the service accepts. */
export declare enum KnownReservedResourceType {
    /** VirtualMachines */
    VirtualMachines = "VirtualMachines",
    /** SqlDatabases */
    SqlDatabases = "SqlDatabases",
    /** SuseLinux */
    SuseLinux = "SuseLinux",
    /** CosmosDb */
    CosmosDb = "CosmosDb",
    /** RedHat */
    RedHat = "RedHat",
    /** SqlDataWarehouse */
    SqlDataWarehouse = "SqlDataWarehouse",
    /** VMwareCloudSimple */
    VMwareCloudSimple = "VMwareCloudSimple",
    /** RedHatOsa */
    RedHatOsa = "RedHatOsa",
    /** Databricks */
    Databricks = "Databricks",
    /** AppService */
    AppService = "AppService",
    /** ManagedDisk */
    ManagedDisk = "ManagedDisk",
    /** BlockBlob */
    BlockBlob = "BlockBlob",
    /** RedisCache */
    RedisCache = "RedisCache",
    /** AzureDataExplorer */
    AzureDataExplorer = "AzureDataExplorer",
    /** MySql */
    MySql = "MySql",
    /** MariaDb */
    MariaDb = "MariaDb",
    /** PostgreSql */
    PostgreSql = "PostgreSql",
    /** DedicatedHost */
    DedicatedHost = "DedicatedHost",
    /** SapHana */
    SapHana = "SapHana",
    /** SqlAzureHybridBenefit */
    SqlAzureHybridBenefit = "SqlAzureHybridBenefit",
    /** AVS */
    AVS = "AVS",
    /** DataFactory */
    DataFactory = "DataFactory",
    /** NetAppStorage */
    NetAppStorage = "NetAppStorage",
    /** AzureFiles */
    AzureFiles = "AzureFiles",
    /** SqlEdge */
    SqlEdge = "SqlEdge",
    /** VirtualMachineSoftware */
    VirtualMachineSoftware = "VirtualMachineSoftware"
}

/** Known values of {@link ResourceType} that the service accepts. */
export declare enum KnownResourceType {
    /** Standard */
    Standard = "standard",
    /** Dedicated */
    Dedicated = "dedicated",
    /** LowPriority */
    LowPriority = "lowPriority",
    /** Shared */
    Shared = "shared",
    /** ServiceSpecific */
    ServiceSpecific = "serviceSpecific"
}

/** Known values of {@link SavingsPlanTerm} that the service accepts. */
export declare enum KnownSavingsPlanTerm {
    /** P1Y */
    P1Y = "P1Y",
    /** P3Y */
    P3Y = "P3Y"
}

/** Known values of {@link UserFriendlyAppliedScopeType} that the service accepts. */
export declare enum KnownUserFriendlyAppliedScopeType {
    /** None */
    None = "None",
    /** Shared */
    Shared = "Shared",
    /** Single */
    Single = "Single",
    /** ResourceGroup */
    ResourceGroup = "ResourceGroup",
    /** ManagementGroup */
    ManagementGroup = "ManagementGroup"
}

/** Known values of {@link UserFriendlyRenewState} that the service accepts. */
export declare enum KnownUserFriendlyRenewState {
    /** On */
    On = "On",
    /** Off */
    Off = "Off",
    /** Renewed */
    Renewed = "Renewed",
    /** NotRenewed */
    NotRenewed = "NotRenewed",
    /** NotApplicable */
    NotApplicable = "NotApplicable"
}

/**
 * Defines values for Location. \
 * {@link KnownLocation} can be used interchangeably with Location,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **westus** \
 * **eastus** \
 * **eastus2** \
 * **northcentralus** \
 * **westus2** \
 * **southcentralus** \
 * **centralus** \
 * **westeurope** \
 * **northeurope** \
 * **eastasia** \
 * **southeastasia** \
 * **japaneast** \
 * **japanwest** \
 * **brazilsouth** \
 * **australiaeast** \
 * **australiasoutheast** \
 * **southindia** \
 * **westindia** \
 * **centralindia** \
 * **canadacentral** \
 * **canadaeast** \
 * **uksouth** \
 * **westcentralus** \
 * **ukwest**
 */
declare type Location_2 = string;
export { Location_2 as Location }

/** The request for reservation merge */
export declare interface MergeRequest {
    /** Format of the resource id should be /providers/Microsoft.Capacity/reservationOrders/{reservationOrderId}/reservations/{reservationId} */
    sources?: string[];
}

/** Interface representing a Operation. */
export declare interface Operation {
    /**
     * List all the operations.
     * @param options The options parameters.
     */
    list(options?: OperationListOptionalParams): PagedAsyncIterableIterator<OperationResponse>;
}

/** Information about an operation */
export declare interface OperationDisplay {
    provider?: string;
    resource?: string;
    operation?: string;
    description?: string;
}

/** Paginated list of operations */
export declare interface OperationList {
    value?: OperationResponse[];
    /** Url to get the next page of items. */
    nextLink?: string;
}

/** Optional parameters. */
export declare interface OperationListNextOptionalParams extends coreClient.OperationOptions {
}

/** Contains response data for the listNext operation. */
export declare type OperationListNextResponse = OperationList;

/** Optional parameters. */
export declare interface OperationListOptionalParams extends coreClient.OperationOptions {
}

/** Contains response data for the list operation. */
export declare type OperationListResponse = OperationList;

/** The response containing operation information */
export declare interface OperationResponse {
    /** Name of the operation */
    name?: string;
    /** Indicates whether the operation is a data action */
    isDataAction?: boolean;
    /** Display of the operation */
    display?: OperationDisplay;
    /** Origin of the operation */
    origin?: string;
    /** Properties of the operation */
    properties?: Record<string, unknown>;
}

/** Required if status == failed or status == canceled. */
export declare interface OperationResultError {
    /** Required if status == failed or status == cancelled. If status == failed, provide an invariant error code used for error troubleshooting, aggregation, and analysis. */
    code?: string;
    /** Required if status == failed. Localized. If status == failed, provide an actionable error message indicating what error occurred, and what the user can do to address the issue. */
    message?: string;
}

/**
 * Defines values for OperationStatus. \
 * {@link KnownOperationStatus} can be used interchangeably with OperationStatus,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **Succeeded** \
 * **Failed** \
 * **Cancelled** \
 * **Pending**
 */
export declare type OperationStatus = string;

/** The request for reservation patch */
export declare interface Patch {
    /** Type of the Applied Scope. */
    appliedScopeType?: AppliedScopeType;
    /** List of the subscriptions that the benefit will be applied. Do not specify if AppliedScopeType is Shared. This property will be deprecated and replaced by appliedScopeProperties instead for Single AppliedScopeType. */
    appliedScopes?: string[];
    /** Properties specific to applied scope type. Not required if not applicable. Required and need to provide tenantId and managementGroupId if AppliedScopeType is ManagementGroup */
    appliedScopeProperties?: AppliedScopeProperties;
    /** Turning this on will apply the reservation discount to other VMs in the same VM size group. Only specify for VirtualMachines reserved resource type. */
    instanceFlexibility?: InstanceFlexibility;
    /** Display name of the reservation */
    name?: string;
    /** Setting this to true will automatically purchase a new reservation on the expiration date time. */
    renew?: boolean;
    renewProperties?: PatchPropertiesRenewProperties;
    /** This is the date-time when the Azure hybrid benefit needs to be reviewed. */
    reviewDateTime?: Date;
}

export declare interface PatchPropertiesRenewProperties {
    /** The request for reservation purchase */
    purchaseProperties?: PurchaseRequest;
}

/** Information about payment related to a reservation order. */
export declare interface PaymentDetail {
    /** Date when the payment needs to be done. */
    dueDate?: Date;
    /** Date when the transaction is completed. Is null when it is scheduled. */
    paymentDate?: Date;
    /** Amount in pricing currency. Tax not included. */
    pricingCurrencyTotal?: Price;
    /** Amount charged in Billing currency. Tax not included. Is null for future payments */
    billingCurrencyTotal?: Price;
    /** Shows the Account that is charged for this payment. */
    billingAccount?: string;
    /** Describes whether the payment is completed, failed, cancelled or scheduled in the future. */
    status?: PaymentStatus;
    extendedStatusInfo?: ExtendedStatusInfo;
}

/**
 * Defines values for PaymentStatus. \
 * {@link KnownPaymentStatus} can be used interchangeably with PaymentStatus,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **Succeeded** \
 * **Failed** \
 * **Scheduled** \
 * **Cancelled**
 */
export declare type PaymentStatus = string;

/** Pricing information containing the amount and the currency code */
export declare interface Price {
    /** The ISO 4217 3-letter currency code for the currency used by this purchase record. */
    currencyCode?: string;
    amount?: number;
}

/**
 * Defines values for ProvisioningState. \
 * {@link KnownProvisioningState} can be used interchangeably with ProvisioningState,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **Creating** \
 * **PendingResourceHold** \
 * **ConfirmedResourceHold** \
 * **PendingBilling** \
 * **ConfirmedBilling** \
 * **Created** \
 * **Succeeded** \
 * **Cancelled** \
 * **Expired** \
 * **BillingFailed** \
 * **Failed** \
 * **Split** \
 * **Merged**
 */
export declare type ProvisioningState = string;

/** The resource model definition for a Azure Resource Manager proxy resource. It will not have tags and a location */
export declare interface ProxyResource extends Resource {
}

/** The request for reservation purchase */
export declare interface PurchaseRequest {
    /** The name of sku */
    sku?: SkuName;
    /** The Azure region where the reserved resource lives. */
    location?: string;
    /** The type of the resource that is being reserved. */
    reservedResourceType?: ReservedResourceType;
    /** Subscription that will be charged for purchasing reservation or savings plan */
    billingScopeId?: string;
    /** Represent the term of reservation. */
    term?: ReservationTerm;
    /** Represent the billing plans. */
    billingPlan?: ReservationBillingPlan;
    /** Quantity of the skus that are part of the reservation. */
    quantity?: number;
    /** Friendly name of the reservation */
    displayName?: string;
    /** Type of the Applied Scope. */
    appliedScopeType?: AppliedScopeType;
    /** List of the subscriptions that the benefit will be applied. Do not specify if AppliedScopeType is Shared. This property will be deprecated and replaced by appliedScopeProperties instead for Single AppliedScopeType. */
    appliedScopes?: string[];
    /** Properties specific to applied scope type. Not required if not applicable. Required and need to provide tenantId and managementGroupId if AppliedScopeType is ManagementGroup */
    appliedScopeProperties?: AppliedScopeProperties;
    /** Setting this to true will automatically purchase a new reservation on the expiration date time. */
    renew?: boolean;
    /** Properties specific to each reserved resource type. Not required if not applicable. */
    reservedResourceProperties?: PurchaseRequestPropertiesReservedResourceProperties;
    /** This is the date-time when the Azure hybrid benefit needs to be reviewed. */
    reviewDateTime?: Date;
}

/** Properties specific to each reserved resource type. Not required if not applicable. */
export declare interface PurchaseRequestPropertiesReservedResourceProperties {
    /** Turning this on will apply the reservation discount to other VMs in the same VM size group. Only specify for VirtualMachines reserved resource type. */
    instanceFlexibility?: InstanceFlexibility;
}

/** Interface representing a Quota. */
export declare interface Quota {
    /**
     * Gets a list of current quotas (service limits) and usage for all resources. The response from the
     * list quota operation can be leveraged to request quota updates.
     * @param subscriptionId Azure subscription ID.
     * @param providerId Azure resource provider ID.
     * @param location Azure region.
     * @param options The options parameters.
     */
    list(subscriptionId: string, providerId: string, location: string, options?: QuotaListOptionalParams): PagedAsyncIterableIterator<CurrentQuotaLimitBase>;
    /**
     * Get the current quota (service limit) and usage of a resource. You can use the response from the GET
     * operation to submit quota update request.
     * @param subscriptionId Azure subscription ID.
     * @param providerId Azure resource provider ID.
     * @param location Azure region.
     * @param resourceName The resource name for a resource provider, such as SKU name for
     *                     Microsoft.Compute, Sku or TotalLowPriorityCores for Microsoft.MachineLearningServices
     * @param options The options parameters.
     */
    get(subscriptionId: string, providerId: string, location: string, resourceName: string, options?: QuotaGetOptionalParams): Promise<QuotaGetResponse>;
    /**
     * Create or update the quota (service limits) of a resource to the requested value.
     *  Steps:
     *   1. Make the Get request to get the quota information for specific resource.
     *   2. To increase the quota, update the limit field in the response from Get request to new value.
     *   3. Submit the JSON to the quota request API to update the quota.
     *   The Create quota request may be constructed as follows. The PUT operation can be used to update
     * the quota.
     * @param subscriptionId Azure subscription ID.
     * @param providerId Azure resource provider ID.
     * @param location Azure region.
     * @param resourceName The resource name for a resource provider, such as SKU name for
     *                     Microsoft.Compute, Sku or TotalLowPriorityCores for Microsoft.MachineLearningServices
     * @param createQuotaRequest Quota requests payload.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(subscriptionId: string, providerId: string, location: string, resourceName: string, createQuotaRequest: CurrentQuotaLimitBase, options?: QuotaCreateOrUpdateOptionalParams): Promise<SimplePollerLike<OperationState<QuotaCreateOrUpdateResponse>, QuotaCreateOrUpdateResponse>>;
    /**
     * Create or update the quota (service limits) of a resource to the requested value.
     *  Steps:
     *   1. Make the Get request to get the quota information for specific resource.
     *   2. To increase the quota, update the limit field in the response from Get request to new value.
     *   3. Submit the JSON to the quota request API to update the quota.
     *   The Create quota request may be constructed as follows. The PUT operation can be used to update
     * the quota.
     * @param subscriptionId Azure subscription ID.
     * @param providerId Azure resource provider ID.
     * @param location Azure region.
     * @param resourceName The resource name for a resource provider, such as SKU name for
     *                     Microsoft.Compute, Sku or TotalLowPriorityCores for Microsoft.MachineLearningServices
     * @param createQuotaRequest Quota requests payload.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(subscriptionId: string, providerId: string, location: string, resourceName: string, createQuotaRequest: CurrentQuotaLimitBase, options?: QuotaCreateOrUpdateOptionalParams): Promise<QuotaCreateOrUpdateResponse>;
    /**
     * Update the quota (service limits) of this resource to the requested value.
     *   • To get the quota information for specific resource, send a GET request.
     *   • To increase the quota, update the limit field from the GET response to a new value.
     *   • To update the quota value, submit the JSON response to the quota request API to update the
     * quota.
     *   • To update the quota. use the PATCH operation.
     * @param subscriptionId Azure subscription ID.
     * @param providerId Azure resource provider ID.
     * @param location Azure region.
     * @param resourceName The resource name for a resource provider, such as SKU name for
     *                     Microsoft.Compute, Sku or TotalLowPriorityCores for Microsoft.MachineLearningServices
     * @param createQuotaRequest Payload for the quota request.
     * @param options The options parameters.
     */
    beginUpdate(subscriptionId: string, providerId: string, location: string, resourceName: string, createQuotaRequest: CurrentQuotaLimitBase, options?: QuotaUpdateOptionalParams): Promise<SimplePollerLike<OperationState<QuotaUpdateResponse>, QuotaUpdateResponse>>;
    /**
     * Update the quota (service limits) of this resource to the requested value.
     *   • To get the quota information for specific resource, send a GET request.
     *   • To increase the quota, update the limit field from the GET response to a new value.
     *   • To update the quota value, submit the JSON response to the quota request API to update the
     * quota.
     *   • To update the quota. use the PATCH operation.
     * @param subscriptionId Azure subscription ID.
     * @param providerId Azure resource provider ID.
     * @param location Azure region.
     * @param resourceName The resource name for a resource provider, such as SKU name for
     *                     Microsoft.Compute, Sku or TotalLowPriorityCores for Microsoft.MachineLearningServices
     * @param createQuotaRequest Payload for the quota request.
     * @param options The options parameters.
     */
    beginUpdateAndWait(subscriptionId: string, providerId: string, location: string, resourceName: string, createQuotaRequest: CurrentQuotaLimitBase, options?: QuotaUpdateOptionalParams): Promise<QuotaUpdateResponse>;
}

/** Optional parameters. */
export declare interface QuotaCreateOrUpdateOptionalParams extends coreClient.OperationOptions {
    /** Delay to wait until next poll, in milliseconds. */
    updateIntervalInMs?: number;
    /** A serialized poller which can be used to resume an existing paused Long-Running-Operation. */
    resumeFrom?: string;
}

/** Contains response data for the createOrUpdate operation. */
export declare type QuotaCreateOrUpdateResponse = CurrentQuotaLimitBase;

/** Defines headers for Quota_get operation. */
export declare interface QuotaGetHeaders {
    /** Current entity state version. It should be treated as opaque and used to make conditional HTTP requests. */
    eTag?: string;
}

/** Optional parameters. */
export declare interface QuotaGetOptionalParams extends coreClient.OperationOptions {
}

/** Contains response data for the get operation. */
export declare type QuotaGetResponse = QuotaGetHeaders & CurrentQuotaLimitBase;

/** Quota limits. */
export declare interface QuotaLimits {
    /** List of quotas (service limits). */
    value?: CurrentQuotaLimitBase[];
    /** The URI for fetching the next page of quotas (service limits). When no more pages exist, the value is null. */
    nextLink?: string;
}

/** Quotas (service limits) in the request response. */
export declare interface QuotaLimitsResponse {
    /** List of quotas with the quota request status. */
    value?: CurrentQuotaLimit[];
    /** The URI for fetching the next page of quota limits. When no more pages exist, the value is null. */
    nextLink?: string;
}

/** Defines headers for Quota_list operation. */
export declare interface QuotaListHeaders {
    /** Current entity state version. Should be treated as opaque and used to make conditional HTTP requests. */
    eTag?: string;
}

/** Defines headers for Quota_listNext operation. */
export declare interface QuotaListNextHeaders {
    /** Current entity state version. Should be treated as opaque and used to make conditional HTTP requests. */
    eTag?: string;
}

/** Optional parameters. */
export declare interface QuotaListNextOptionalParams extends coreClient.OperationOptions {
}

/** Contains response data for the listNext operation. */
export declare type QuotaListNextResponse = QuotaListNextHeaders & QuotaLimits;

/** Optional parameters. */
export declare interface QuotaListOptionalParams extends coreClient.OperationOptions {
}

/** Contains response data for the list operation. */
export declare type QuotaListResponse = QuotaListHeaders & QuotaLimits;

/** Quota properties for the resource. */
export declare interface QuotaProperties {
    /** Quota properties. */
    limit?: number;
    /**
     * Current usage value for the resource.
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly currentValue?: number;
    /**  The limit units, such as **count** and **bytes**. Use the unit field provided in the response of the GET quota operation. */
    unit?: string;
    /** Name of the resource provide by the resource provider. Use this property for quotaRequests resource operations. */
    name?: ResourceName;
    /** The name of the resource type. */
    resourceType?: ResourceType;
    /**
     * The time period over which the quota usage values are summarized. For example, P1D (per one day), PT1M (per one minute), and PT1S (per one second). This parameter is optional because, for some resources such as compute, the time period is irrelevant.
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly quotaPeriod?: string;
    /** Additional properties for the specified resource provider. */
    properties?: Record<string, unknown>;
}

/** Quota request details. */
export declare interface QuotaRequestDetails {
    /**
     * Quota request ID.
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly id?: string;
    /**
     * Quota request name.
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly name?: string;
    /**
     * Resource type
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly type?: string;
    /** The quota request status. */
    provisioningState?: QuotaRequestState;
    /**
     * User friendly status message.
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly message?: string;
    /**
     * The time when the quota request was submitted using format: yyyy-MM-ddTHH:mm:ssZ as specified by the ISO 8601 standard.
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly requestSubmitTime?: Date;
    /** The quotaRequests. */
    value?: SubRequest[];
}

/** Quota request details. */
export declare interface QuotaRequestDetailsList {
    /** The quota requests. */
    value?: QuotaRequestDetails[];
    /** The URI to fetch the next page of quota limits. When there are no more pages, this is null. */
    nextLink?: string;
}

/** Response for the quota submission request. */
export declare interface QuotaRequestOneResourceSubmitResponse {
    /**
     * The quota request ID.
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly id?: string;
    /**
     * The name of the quota request.
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly name?: string;
    /**
     * Type of resource. "Microsoft.Capacity/ServiceLimits"
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly type?: string;
    /**
     * The quota request status.
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly provisioningState?: QuotaRequestState;
    /**
     * User friendly status message.
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly message?: string;
    /**
     * The time when the quota request was submitted using format: yyyy-MM-ddTHH:mm:ssZ as specified by the ISO 8601 standard.
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly requestSubmitTime?: Date;
    /**
     * The quota request ID.
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly idPropertiesId?: string;
    /**
     * The name of the quota request.
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly namePropertiesName?: string;
    /**
     * Type of resource. "Microsoft.Capacity/ServiceLimits"
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly typePropertiesType?: string;
    /** Quota properties for the resource. */
    properties?: QuotaProperties;
}

/** The details of quota request. */
export declare interface QuotaRequestProperties {
    /** The quota request status. */
    provisioningState?: QuotaRequestState;
    /**
     * User friendly status message.
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly message?: string;
    /**
     * The time when the quota request was submitted using format: yyyy-MM-ddTHH:mm:ssZ as specified by the ISO 8601 standard.
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly requestSubmitTime?: Date;
    /** The quotaRequests. */
    value?: SubRequest[];
}

/**
 * Defines values for QuotaRequestState. \
 * {@link KnownQuotaRequestState} can be used interchangeably with QuotaRequestState,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **Accepted** \
 * **Invalid** \
 * **Succeeded** \
 * **Failed** \
 * **InProgress**
 */
export declare type QuotaRequestState = string;

/** Interface representing a QuotaRequestStatus. */
export declare interface QuotaRequestStatus {
    /**
     * For the specified Azure region (location), subscription, and resource provider, get the history of
     * the quota requests for the past year. To select specific quota requests, use the oData filter.
     * @param subscriptionId Azure subscription ID.
     * @param providerId Azure resource provider ID.
     * @param location Azure region.
     * @param options The options parameters.
     */
    list(subscriptionId: string, providerId: string, location: string, options?: QuotaRequestStatusListOptionalParams): PagedAsyncIterableIterator<QuotaRequestDetails>;
    /**
     * For the specified Azure region (location), get the details and status of the quota request by the
     * quota request ID for the resources of the resource provider. The PUT request for the quota (service
     * limit) returns a response with the requestId parameter.
     * @param subscriptionId Azure subscription ID.
     * @param providerId Azure resource provider ID.
     * @param location Azure region.
     * @param id Quota Request ID.
     * @param options The options parameters.
     */
    get(subscriptionId: string, providerId: string, location: string, id: string, options?: QuotaRequestStatusGetOptionalParams): Promise<QuotaRequestStatusGetResponse>;
}

/** Optional parameters. */
export declare interface QuotaRequestStatusGetOptionalParams extends coreClient.OperationOptions {
}

/** Contains response data for the get operation. */
export declare type QuotaRequestStatusGetResponse = QuotaRequestDetails;

/** Optional parameters. */
export declare interface QuotaRequestStatusListNextOptionalParams extends coreClient.OperationOptions {
}

/** Contains response data for the listNext operation. */
export declare type QuotaRequestStatusListNextResponse = QuotaRequestDetailsList;

/** Optional parameters. */
export declare interface QuotaRequestStatusListOptionalParams extends coreClient.OperationOptions {
    /**
     * | Field | Supported operators |
     * |---------------------|------------------------|
     * |requestSubmitTime | ge, le, eq, gt, lt |
     */
    filter?: string;
    /** Number of records to return. */
    top?: number;
    /** Skiptoken is only used if a previous operation returned a partial result. If a previous response contains a nextLink element, the value of the nextLink element includes a skiptoken parameter that specifies a starting point to use for subsequent calls. */
    skiptoken?: string;
}

/** Contains response data for the list operation. */
export declare type QuotaRequestStatusListResponse = QuotaRequestDetailsList;

/** Response for the quota submission request. */
export declare interface QuotaRequestSubmitResponse {
    /**
     * The quota request ID.
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly id?: string;
    /**
     * The name of the quota request.
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly name?: string;
    /** The quota request details. */
    properties?: QuotaRequestProperties;
    /**
     * Type of resource. "Microsoft.Capacity/serviceLimits"
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly type?: string;
}

/** Response with request ID that the quota request was accepted. */
export declare interface QuotaRequestSubmitResponse201 {
    /**
     * The quota request ID. Use the requestId parameter to check the request status.
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly id?: string;
    /**
     * Operation ID
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly name?: string;
    /**
     * Resource type
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly type?: string;
    /**
     * The details of the quota request status.
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly provisioningState?: QuotaRequestState;
    /**
     * A user friendly message.
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly message?: string;
}

/** Optional parameters. */
export declare interface QuotaUpdateOptionalParams extends coreClient.OperationOptions {
    /** Delay to wait until next poll, in milliseconds. */
    updateIntervalInMs?: number;
    /** A serialized poller which can be used to resume an existing paused Long-Running-Operation. */
    resumeFrom?: string;
}

/** Contains response data for the update operation. */
export declare type QuotaUpdateResponse = CurrentQuotaLimitBase;

/** billing information */
export declare interface RefundBillingInformation {
    /** Represent the billing plans. */
    billingPlan?: ReservationBillingPlan;
    /** The number of completed transactions in this reservation's payment */
    completedTransactions?: number;
    /** The number of total transactions in this reservation's payment */
    totalTransactions?: number;
    /** Pricing information containing the amount and the currency code */
    billingCurrencyTotalPaidAmount?: Price;
    /** Pricing information containing the amount and the currency code */
    billingCurrencyProratedAmount?: Price;
    /** Pricing information containing the amount and the currency code */
    billingCurrencyRemainingCommitmentAmount?: Price;
}

/** error details */
export declare interface RefundPolicyError {
    /** Error code describing the reason that service is not able to process the incoming request */
    code?: ErrorResponseCode;
    message?: string;
}

/** Refund policy result */
export declare interface RefundPolicyResult {
    /** Refund policy result property */
    properties?: RefundPolicyResultProperty;
}

/** Refund policy result property */
export declare interface RefundPolicyResultProperty {
    /** Pricing information containing the amount and the currency code */
    consumedRefundsTotal?: Price;
    /** Pricing information containing the amount and the currency code */
    maxRefundLimit?: Price;
    /** Refund Policy errors */
    policyErrors?: RefundPolicyError[];
}

/** Request containing information needed for returning reservation. */
export declare interface RefundRequest {
    /** Properties needed for refund request including the session id from calculate refund, the scope, the reservation to be returned and the return reason. */
    properties?: RefundRequestProperties;
}

/** Properties needed for refund request including the session id from calculate refund, the scope, the reservation to be returned and the return reason. */
export declare interface RefundRequestProperties {
    /** SessionId that was returned by CalculateRefund API. */
    sessionId?: string;
    /** The scope of the refund, e.g. Reservation */
    scope?: string;
    /** Reservation to return */
    reservationToReturn?: ReservationToReturn;
    /** The reason of returning the reservation */
    returnReason?: string;
}

/** The response of refund request containing refund information of reservation */
export declare interface RefundResponse {
    /** Fully qualified identifier of the reservation being returned */
    id?: string;
    /** The refund properties of reservation */
    properties?: RefundResponseProperties;
}

/** The refund properties of reservation */
export declare interface RefundResponseProperties {
    /** Refund session identifier */
    sessionId?: string;
    /** Quantity to be returned */
    quantity?: number;
    /** Pricing information containing the amount and the currency code */
    billingRefundAmount?: Price;
    /** Pricing information containing the amount and the currency code */
    pricingRefundAmount?: Price;
    /** Refund policy result */
    policyResult?: RefundPolicyResult;
    /** billing information */
    billingInformation?: RefundBillingInformation;
}

/** The renew properties for a reservation. */
export declare interface RenewPropertiesResponse {
    /** The request for reservation purchase */
    purchaseProperties?: PurchaseRequest;
    /** Amount that Microsoft uses for record. Used during refund for calculating refund limit. Tax is not included. This is locked price 30 days before expiry. */
    pricingCurrencyTotal?: RenewPropertiesResponsePricingCurrencyTotal;
    /** Currency and amount that customer will be charged in customer's local currency for renewal purchase. Tax is not included. */
    billingCurrencyTotal?: RenewPropertiesResponseBillingCurrencyTotal;
}

/** Currency and amount that customer will be charged in customer's local currency for renewal purchase. Tax is not included. */
export declare interface RenewPropertiesResponseBillingCurrencyTotal {
    /** The ISO 4217 3-letter currency code for the currency used by this purchase record. */
    currencyCode?: string;
    amount?: number;
}

/** Amount that Microsoft uses for record. Used during refund for calculating refund limit. Tax is not included. This is locked price 30 days before expiry. */
export declare interface RenewPropertiesResponsePricingCurrencyTotal {
    /** The ISO 4217 3-letter currency code for the currency used by this purchase record. */
    currencyCode?: string;
    amount?: number;
}

/** Interface representing a Reservation. */
export declare interface Reservation {
    /**
     * List `Reservation`s within a single `ReservationOrder`.
     * @param reservationOrderId Order Id of the reservation
     * @param options The options parameters.
     */
    list(reservationOrderId: string, options?: ReservationListOptionalParams): PagedAsyncIterableIterator<ReservationResponse>;
    /**
     * List of all the revisions for the `Reservation`.
     * @param reservationOrderId Order Id of the reservation
     * @param reservationId Id of the reservation item
     * @param options The options parameters.
     */
    listRevisions(reservationOrderId: string, reservationId: string, options?: ReservationListRevisionsOptionalParams): PagedAsyncIterableIterator<ReservationResponse>;
    /**
     * List the reservations and the roll up counts of reservations group by provisioning states that the
     * user has access to in the current tenant.
     * @param options The options parameters.
     */
    listAll(options?: ReservationListAllOptionalParams): PagedAsyncIterableIterator<ReservationResponse>;
    /**
     * Check whether the scopes from request is valid for `Reservation`.
     *
     * @param reservationOrderId Order Id of the reservation
     * @param reservationId Id of the reservation item
     * @param body Scopes to be checked for eligibility.
     * @param options The options parameters.
     */
    beginAvailableScopes(reservationOrderId: string, reservationId: string, body: AvailableScopeRequest, options?: ReservationAvailableScopesOptionalParams): Promise<SimplePollerLike<OperationState<ReservationAvailableScopesResponse>, ReservationAvailableScopesResponse>>;
    /**
     * Check whether the scopes from request is valid for `Reservation`.
     *
     * @param reservationOrderId Order Id of the reservation
     * @param reservationId Id of the reservation item
     * @param body Scopes to be checked for eligibility.
     * @param options The options parameters.
     */
    beginAvailableScopesAndWait(reservationOrderId: string, reservationId: string, body: AvailableScopeRequest, options?: ReservationAvailableScopesOptionalParams): Promise<ReservationAvailableScopesResponse>;
    /**
     * Split a `Reservation` into two `Reservation`s with specified quantity distribution.
     * @param reservationOrderId Order Id of the reservation
     * @param body Information needed to Split a reservation item
     * @param options The options parameters.
     */
    beginSplit(reservationOrderId: string, body: SplitRequest, options?: ReservationSplitOptionalParams): Promise<SimplePollerLike<OperationState<ReservationSplitResponse>, ReservationSplitResponse>>;
    /**
     * Split a `Reservation` into two `Reservation`s with specified quantity distribution.
     * @param reservationOrderId Order Id of the reservation
     * @param body Information needed to Split a reservation item
     * @param options The options parameters.
     */
    beginSplitAndWait(reservationOrderId: string, body: SplitRequest, options?: ReservationSplitOptionalParams): Promise<ReservationSplitResponse>;
    /**
     * Merge the specified `Reservation`s into a new `Reservation`. The two `Reservation`s being merged
     * must have same properties.
     * @param reservationOrderId Order Id of the reservation
     * @param body Information needed for commercial request for a reservation
     * @param options The options parameters.
     */
    beginMerge(reservationOrderId: string, body: MergeRequest, options?: ReservationMergeOptionalParams): Promise<SimplePollerLike<OperationState<ReservationMergeResponse>, ReservationMergeResponse>>;
    /**
     * Merge the specified `Reservation`s into a new `Reservation`. The two `Reservation`s being merged
     * must have same properties.
     * @param reservationOrderId Order Id of the reservation
     * @param body Information needed for commercial request for a reservation
     * @param options The options parameters.
     */
    beginMergeAndWait(reservationOrderId: string, body: MergeRequest, options?: ReservationMergeOptionalParams): Promise<ReservationMergeResponse>;
    /**
     * Get specific `Reservation` details.
     * @param reservationOrderId Order Id of the reservation
     * @param reservationId Id of the reservation item
     * @param options The options parameters.
     */
    get(reservationOrderId: string, reservationId: string, options?: ReservationGetOptionalParams): Promise<ReservationGetResponse>;
    /**
     * Updates the applied scopes of the `Reservation`.
     * @param reservationOrderId Order Id of the reservation
     * @param reservationId Id of the reservation item
     * @param parameters Information needed to patch a reservation item
     * @param options The options parameters.
     */
    beginUpdate(reservationOrderId: string, reservationId: string, parameters: Patch, options?: ReservationUpdateOptionalParams): Promise<SimplePollerLike<OperationState<ReservationUpdateResponse>, ReservationUpdateResponse>>;
    /**
     * Updates the applied scopes of the `Reservation`.
     * @param reservationOrderId Order Id of the reservation
     * @param reservationId Id of the reservation item
     * @param parameters Information needed to patch a reservation item
     * @param options The options parameters.
     */
    beginUpdateAndWait(reservationOrderId: string, reservationId: string, parameters: Patch, options?: ReservationUpdateOptionalParams): Promise<ReservationUpdateResponse>;
    /**
     * Archiving a `Reservation` moves it to `Archived` state.
     * @param reservationOrderId Order Id of the reservation
     * @param reservationId Id of the reservation item
     * @param options The options parameters.
     */
    archive(reservationOrderId: string, reservationId: string, options?: ReservationArchiveOptionalParams): Promise<void>;
    /**
     * Restores a `Reservation` to the state it was before archiving.
     *
     * @param reservationOrderId Order Id of the reservation
     * @param reservationId Id of the reservation item
     * @param options The options parameters.
     */
    unarchive(reservationOrderId: string, reservationId: string, options?: ReservationUnarchiveOptionalParams): Promise<void>;
}

/** Optional parameters. */
export declare interface ReservationArchiveOptionalParams extends coreClient.OperationOptions {
}

/** Optional parameters. */
export declare interface ReservationAvailableScopesOptionalParams extends coreClient.OperationOptions {
    /** Delay to wait until next poll, in milliseconds. */
    updateIntervalInMs?: number;
    /** A serialized poller which can be used to resume an existing paused Long-Running-Operation. */
    resumeFrom?: string;
}

/** Contains response data for the availableScopes operation. */
export declare type ReservationAvailableScopesResponse = AvailableScopeProperties;

/**
 * Defines values for ReservationBillingPlan. \
 * {@link KnownReservationBillingPlan} can be used interchangeably with ReservationBillingPlan,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **Upfront** \
 * **Monthly**
 */
export declare type ReservationBillingPlan = string;

/** Optional parameters. */
export declare interface ReservationGetOptionalParams extends coreClient.OperationOptions {
    /** Supported value of this query is renewProperties */
    expand?: string;
}

/** Contains response data for the get operation. */
export declare type ReservationGetResponse = ReservationResponse;

/** List of `Reservation`s */
export declare interface ReservationList {
    value?: ReservationResponse[];
    /** Url to get the next page of reservations. */
    nextLink?: string;
}

/** Optional parameters. */
export declare interface ReservationListAllNextOptionalParams extends coreClient.OperationOptions {
}

/** Contains response data for the listAllNext operation. */
export declare type ReservationListAllNextResponse = ReservationsListResult;

/** Optional parameters. */
export declare interface ReservationListAllOptionalParams extends coreClient.OperationOptions {
    /** May be used to filter by reservation properties. The filter supports 'eq', 'or', and 'and'. It does not currently support 'ne', 'gt', 'le', 'ge', or 'not'. Reservation properties include sku/name, properties/{appliedScopeType, archived, displayName, displayProvisioningState, effectiveDateTime, expiryDate, expiryDateTime, provisioningState, quantity, renew, reservedResourceType, term, userFriendlyAppliedScopeType, userFriendlyRenewState} */
    filter?: string;
    /** May be used to sort order by reservation properties. */
    orderby?: string;
    /** To indicate whether to refresh the roll up counts of the reservations group by provisioning states */
    refreshSummary?: string;
    /** The number of reservations to skip from the list before returning results */
    skiptoken?: number;
    /** The selected provisioning state */
    selectedState?: string;
    /** To number of reservations to return */
    take?: number;
}

/** Contains response data for the listAll operation. */
export declare type ReservationListAllResponse = ReservationsListResult;

/** Optional parameters. */
export declare interface ReservationListNextOptionalParams extends coreClient.OperationOptions {
}

/** Contains response data for the listNext operation. */
export declare type ReservationListNextResponse = ReservationList;

/** Optional parameters. */
export declare interface ReservationListOptionalParams extends coreClient.OperationOptions {
}

/** Contains response data for the list operation. */
export declare type ReservationListResponse = ReservationList;

/** Optional parameters. */
export declare interface ReservationListRevisionsNextOptionalParams extends coreClient.OperationOptions {
}

/** Contains response data for the listRevisionsNext operation. */
export declare type ReservationListRevisionsNextResponse = ReservationList;

/** Optional parameters. */
export declare interface ReservationListRevisionsOptionalParams extends coreClient.OperationOptions {
}

/** Contains response data for the listRevisions operation. */
export declare type ReservationListRevisionsResponse = ReservationList;

/** Defines headers for Reservation_merge operation. */
export declare interface ReservationMergeHeaders {
    /** URL for determining when an operation has completed. Only use this value only when Azure-AsyncOperation isn't returned. */
    location?: string;
    /** Clients should wait for the Retry-After interval before polling again */
    retryAfter?: number;
}

/** Optional parameters. */
export declare interface ReservationMergeOptionalParams extends coreClient.OperationOptions {
    /** Delay to wait until next poll, in milliseconds. */
    updateIntervalInMs?: number;
    /** A serialized poller which can be used to resume an existing paused Long-Running-Operation. */
    resumeFrom?: string;
}

/** Properties of reservation merge */
export declare interface ReservationMergeProperties {
    /** Reservation resource id Created due to the merge. Format of the resource id is /providers/Microsoft.Capacity/reservationOrders/{reservationOrderId}/reservations/{reservationId} */
    mergeDestination?: string;
    /** Resource ids of the source reservation's merged to form this reservation. Format of the resource id is /providers/Microsoft.Capacity/reservationOrders/{reservationOrderId}/reservations/{reservationId} */
    mergeSources?: string[];
}

/** Contains response data for the merge operation. */
export declare type ReservationMergeResponse = ReservationResponse[];

/** Interface representing a ReservationOrder. */
export declare interface ReservationOrder {
    /**
     * List of all the `ReservationOrder`s that the user has access to in the current tenant.
     * @param options The options parameters.
     */
    list(options?: ReservationOrderListOptionalParams): PagedAsyncIterableIterator<ReservationOrderResponse>;
    /**
     * Calculate price for placing a `ReservationOrder`.
     * @param body Information needed for calculate or purchase reservation
     * @param options The options parameters.
     */
    calculate(body: PurchaseRequest, options?: ReservationOrderCalculateOptionalParams): Promise<ReservationOrderCalculateResponse>;
    /**
     * Purchase `ReservationOrder` and create resource under the specified URI.
     * @param reservationOrderId Order Id of the reservation
     * @param body Information needed for calculate or purchase reservation
     * @param options The options parameters.
     */
    beginPurchase(reservationOrderId: string, body: PurchaseRequest, options?: ReservationOrderPurchaseOptionalParams): Promise<SimplePollerLike<OperationState<ReservationOrderPurchaseResponse>, ReservationOrderPurchaseResponse>>;
    /**
     * Purchase `ReservationOrder` and create resource under the specified URI.
     * @param reservationOrderId Order Id of the reservation
     * @param body Information needed for calculate or purchase reservation
     * @param options The options parameters.
     */
    beginPurchaseAndWait(reservationOrderId: string, body: PurchaseRequest, options?: ReservationOrderPurchaseOptionalParams): Promise<ReservationOrderPurchaseResponse>;
    /**
     * Get the details of the `ReservationOrder`.
     * @param reservationOrderId Order Id of the reservation
     * @param options The options parameters.
     */
    get(reservationOrderId: string, options?: ReservationOrderGetOptionalParams): Promise<ReservationOrderGetResponse>;
    /**
     * Change directory (tenant) of `ReservationOrder` and all `Reservation` under it to specified tenant
     * id
     * @param reservationOrderId Order Id of the reservation
     * @param body Information needed to change directory of reservation order
     * @param options The options parameters.
     */
    changeDirectory(reservationOrderId: string, body: ChangeDirectoryRequest, options?: ReservationOrderChangeDirectoryOptionalParams): Promise<ReservationOrderChangeDirectoryResponse>;
}

/** Information describing the type of billing plan for this reservation. */
export declare interface ReservationOrderBillingPlanInformation {
    /** Amount of money to be paid for the Order. Tax is not included. */
    pricingCurrencyTotal?: Price;
    /** Date when the billing plan has started. */
    startDate?: Date;
    /** For recurring billing plans, indicates the date when next payment will be processed. Null when total is paid off. */
    nextPaymentDueDate?: Date;
    transactions?: PaymentDetail[];
}

/** Optional parameters. */
export declare interface ReservationOrderCalculateOptionalParams extends coreClient.OperationOptions {
}

/** Contains response data for the calculate operation. */
export declare type ReservationOrderCalculateResponse = CalculatePriceResponse;

/** Optional parameters. */
export declare interface ReservationOrderChangeDirectoryOptionalParams extends coreClient.OperationOptions {
}

/** Contains response data for the changeDirectory operation. */
export declare type ReservationOrderChangeDirectoryResponse = ChangeDirectoryResponse;

/** Optional parameters. */
export declare interface ReservationOrderGetOptionalParams extends coreClient.OperationOptions {
    /** May be used to expand the planInformation. */
    expand?: string;
}

/** Contains response data for the get operation. */
export declare type ReservationOrderGetResponse = ReservationOrderResponse;

/** List of `ReservationOrder`s */
export declare interface ReservationOrderList {
    value?: ReservationOrderResponse[];
    /** Url to get the next page of reservationOrders. */
    nextLink?: string;
}

/** Optional parameters. */
export declare interface ReservationOrderListNextOptionalParams extends coreClient.OperationOptions {
}

/** Contains response data for the listNext operation. */
export declare type ReservationOrderListNextResponse = ReservationOrderList;

/** Optional parameters. */
export declare interface ReservationOrderListOptionalParams extends coreClient.OperationOptions {
}

/** Contains response data for the list operation. */
export declare type ReservationOrderListResponse = ReservationOrderList;

/** Defines headers for ReservationOrder_purchase operation. */
export declare interface ReservationOrderPurchaseHeaders {
    /** URL for determining when an operation has completed. Only use this value only when Azure-AsyncOperation isn't returned. */
    location?: string;
    /** Clients should wait for the Retry-After interval before polling again */
    retryAfter?: number;
}

/** Optional parameters. */
export declare interface ReservationOrderPurchaseOptionalParams extends coreClient.OperationOptions {
    /** Delay to wait until next poll, in milliseconds. */
    updateIntervalInMs?: number;
    /** A serialized poller which can be used to resume an existing paused Long-Running-Operation. */
    resumeFrom?: string;
}

/** Contains response data for the purchase operation. */
export declare type ReservationOrderPurchaseResponse = ReservationOrderResponse;

/** Details of a reservation order being returned. */
export declare interface ReservationOrderResponse {
    etag?: number;
    /**
     * Identifier of the reservation
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly id?: string;
    /**
     * Name of the reservation
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly name?: string;
    /**
     * Type of resource. "Microsoft.Capacity/reservations"
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly type?: string;
    /**
     * Metadata pertaining to creation and last modification of the resource.
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly systemData?: SystemData;
    /** Friendly name for user to easily identified the reservation. */
    displayName?: string;
    /** This is the DateTime when the reservation was initially requested for purchase. */
    requestDateTime?: Date;
    /** This is the DateTime when the reservation was created. */
    createdDateTime?: Date;
    /** This is the date when the reservation will expire. */
    expiryDate?: Date;
    /** This is the date-time when the reservation will expire. */
    expiryDateTime?: Date;
    /** This is the DateTime when the reservation benefit started. */
    benefitStartTime?: Date;
    /** Total Quantity of the skus purchased in the reservation. */
    originalQuantity?: number;
    /** Represent the term of reservation. */
    term?: ReservationTerm;
    /** Current state of the reservation. */
    provisioningState?: ProvisioningState;
    /** Represent the billing plans. */
    billingPlan?: ReservationBillingPlan;
    /** Information describing the type of billing plan for this reservation. */
    planInformation?: ReservationOrderBillingPlanInformation;
    reservations?: ReservationResponse[];
    /** This is the date-time when the Azure Hybrid Benefit needs to be reviewed. */
    reviewDateTime?: Date;
}

/** The definition of the reservation. */
export declare interface ReservationResponse extends ProxyResource {
    /** The Azure region where the reserved resource lives. */
    location?: string;
    etag?: number;
    /** The sku information associated to this reservation */
    sku?: SkuName;
    /** The properties associated to this reservation */
    properties?: ReservationsProperties;
    /** Resource Provider type to be reserved. */
    kind?: "Microsoft.Compute";
}

/** The list of reservations and summary of roll out count of reservations in each state. */
export declare interface ReservationsListResult {
    /**
     * The list of reservations.
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly value?: ReservationResponse[];
    /**
     * The link (url) to the next page of results.
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly nextLink?: string;
    /** The roll out count summary of the reservations */
    summary?: ReservationSummary;
}

/** Defines headers for Reservation_split operation. */
export declare interface ReservationSplitHeaders {
    /** URL for determining when an operation has completed. Only use this value only when Azure-AsyncOperation isn't returned. */
    location?: string;
    /** Clients should wait for the Retry-After interval before polling again */
    retryAfter?: number;
}

/** Optional parameters. */
export declare interface ReservationSplitOptionalParams extends coreClient.OperationOptions {
    /** Delay to wait until next poll, in milliseconds. */
    updateIntervalInMs?: number;
    /** A serialized poller which can be used to resume an existing paused Long-Running-Operation. */
    resumeFrom?: string;
}

/** Properties of reservation split */
export declare interface ReservationSplitProperties {
    /** List of destination resource id that are created due to split. Format of the resource id is /providers/Microsoft.Capacity/reservationOrders/{reservationOrderId}/reservations/{reservationId} */
    splitDestinations?: string[];
    /** Resource id of the reservation from which this is split. Format of the resource id is /providers/Microsoft.Capacity/reservationOrders/{reservationOrderId}/reservations/{reservationId} */
    splitSource?: string;
}

/** Contains response data for the split operation. */
export declare type ReservationSplitResponse = ReservationResponse[];

/** The properties of the reservations */
export declare interface ReservationsProperties {
    /** The type of the resource that is being reserved. */
    reservedResourceType?: ReservedResourceType;
    /** Allows reservation discount to be applied across skus within the same auto fit group. Not all skus support instance size flexibility. */
    instanceFlexibility?: InstanceFlexibility;
    /** Friendly name for user to easily identify the reservation */
    displayName?: string;
    /** The list of applied scopes */
    appliedScopes?: string[];
    /** The applied scope type */
    appliedScopeType?: AppliedScopeType;
    /** Indicates if the reservation is archived */
    archived?: boolean;
    /** Capabilities of the reservation */
    capabilities?: string;
    /** Quantity of the skus that are part of the reservation. */
    quantity?: number;
    /** Current state of the reservation. */
    provisioningState?: ProvisioningState;
    /** DateTime of the reservation starting when this version is effective from. */
    effectiveDateTime?: Date;
    /** This is the DateTime when the reservation benefit started. */
    benefitStartTime?: Date;
    /**
     * DateTime of the last time the reservation was updated.
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly lastUpdatedDateTime?: Date;
    /** This is the date when the reservation will expire. */
    expiryDate?: Date;
    /** This is the date-time when the reservation will expire. */
    expiryDateTime?: Date;
    /** This is the date-time when the Azure Hybrid Benefit needs to be reviewed. */
    reviewDateTime?: Date;
    /** Description of the sku in english. */
    skuDescription?: string;
    /** The message giving detailed information about the status code. */
    extendedStatusInfo?: ExtendedStatusInfo;
    /** The billing plan options available for this sku. */
    billingPlan?: ReservationBillingPlan;
    /**
     * The provisioning state of the reservation for display, e.g. Succeeded
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly displayProvisioningState?: string;
    /**
     * The provisioning sub-state of the reservation, e.g. Succeeded
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly provisioningSubState?: string;
    /** This is the date when the reservation was purchased. */
    purchaseDate?: Date;
    /** This is the date-time when the reservation was purchased. */
    purchaseDateTime?: Date;
    /** Properties of reservation split */
    splitProperties?: ReservationSplitProperties;
    /** Properties of reservation merge */
    mergeProperties?: ReservationMergeProperties;
    /** Properties of reservation swap */
    swapProperties?: ReservationSwapProperties;
    /** Properties specific to applied scope type. Not required if not applicable. Required and need to provide tenantId and managementGroupId if AppliedScopeType is ManagementGroup */
    appliedScopeProperties?: AppliedScopeProperties;
    /** Subscription that will be charged for purchasing reservation or savings plan */
    billingScopeId?: string;
    /** Setting this to true will automatically purchase a new reservation on the expiration date time. */
    renew?: boolean;
    /** Reservation Id of the reservation from which this reservation is renewed. Format of the resource Id is /providers/Microsoft.Capacity/reservationOrders/{reservationOrderId}/reservations/{reservationId}. */
    renewSource?: string;
    /** Reservation Id of the reservation which is purchased because of renew. Format of the resource Id is /providers/Microsoft.Capacity/reservationOrders/{reservationOrderId}/reservations/{reservationId}. */
    renewDestination?: string;
    /** The renew properties for a reservation. */
    renewProperties?: RenewPropertiesResponse;
    /** Represent the term of reservation. */
    term?: ReservationTerm;
    /**
     * The applied scope type of the reservation for display, e.g. Shared
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly userFriendlyAppliedScopeType?: string;
    /**
     * The renew state of the reservation for display, e.g. On
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly userFriendlyRenewState?: string;
    /**
     * Reservation utilization
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly utilization?: ReservationsPropertiesUtilization;
}

/** Reservation utilization */
export declare interface ReservationsPropertiesUtilization {
    /**
     * last 7 day utilization trend for a reservation
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly trend?: string;
    /** The array of aggregates of a reservation's utilization */
    aggregates?: ReservationUtilizationAggregates[];
}

/**
 * Defines values for ReservationStatusCode. \
 * {@link KnownReservationStatusCode} can be used interchangeably with ReservationStatusCode,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **None** \
 * **Pending** \
 * **Processing** \
 * **Active** \
 * **PurchaseError** \
 * **PaymentInstrumentError** \
 * **Split** \
 * **Merged** \
 * **Expired** \
 * **Succeeded**
 */
export declare type ReservationStatusCode = string;

/** The roll up count summary of reservations in each state */
export declare interface ReservationSummary {
    /**
     * The number of reservation in Succeeded state
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly succeededCount?: number;
    /**
     * The number of reservation in Failed state
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly failedCount?: number;
    /**
     * The number of reservation in Expiring state
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly expiringCount?: number;
    /**
     * The number of reservation in Expired state
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly expiredCount?: number;
    /**
     * The number of reservation in Pending state
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly pendingCount?: number;
    /**
     * The number of reservation in Cancelled state
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly cancelledCount?: number;
    /**
     * The number of reservation in Processing state
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly processingCount?: number;
    /**
     * The number of reservation in Warning state
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly warningCount?: number;
    /**
     * The number of reservation in NoBenefit state
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly noBenefitCount?: number;
}

/** Properties of reservation swap */
export declare interface ReservationSwapProperties {
    /** Resource id of the source reservation that gets swapped. Format of the resource id is /providers/microsoft.capacity/reservationOrders/{reservationOrderId}/reservations/{reservationId} */
    swapSource?: string;
    /** Reservation resource id that the original resource gets swapped to. Format of the resource id is /providers/microsoft.capacity/reservationOrders/{reservationOrderId}/reservations/{reservationId} */
    swapDestination?: string;
}

/**
 * Defines values for ReservationTerm. \
 * {@link KnownReservationTerm} can be used interchangeably with ReservationTerm,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **P1Y** \
 * **P3Y** \
 * **P5Y**
 */
export declare type ReservationTerm = string;

/** Reservation refund details */
export declare interface ReservationToExchange {
    /** Fully qualified id of the reservation being returned. */
    reservationId?: string;
    /** Quantity to be returned */
    quantity?: number;
    /** Pricing information containing the amount and the currency code */
    billingRefundAmount?: Price;
    /** billing information */
    billingInformation?: BillingInformation;
}

/** Reservation purchase details */
export declare interface ReservationToPurchaseCalculateExchange {
    /** The request for reservation purchase */
    properties?: PurchaseRequest;
    /** Pricing information containing the amount and the currency code */
    billingCurrencyTotal?: Price;
}

/** Reservation purchase details */
export declare interface ReservationToPurchaseExchange {
    /** Fully qualified id of the reservationOrder being purchased */
    reservationOrderId?: string;
    /** Fully qualified id of the reservation being purchased. This value is only guaranteed to be non-null if the purchase is successful. */
    reservationId?: string;
    /** The request for reservation purchase */
    properties?: PurchaseRequest;
    /** Pricing information containing the amount and the currency code */
    billingCurrencyTotal?: Price;
    /** Status of the individual operation. */
    status?: OperationStatus;
}

/** Reservation to return */
export declare interface ReservationToReturn {
    /** Fully qualified identifier of the reservation being returned */
    reservationId?: string;
    /** Quantity to be returned. Must be greater than zero. */
    quantity?: number;
}

/** Reservation refund details */
export declare interface ReservationToReturnForExchange {
    /** Fully qualified id of the reservation being returned. */
    reservationId?: string;
    /** Quantity to be returned */
    quantity?: number;
    /** Pricing information containing the amount and the currency code */
    billingRefundAmount?: Price;
    /** billing information */
    billingInformation?: BillingInformation;
    /** Status of the individual operation. */
    status?: OperationStatus;
}

/** Optional parameters. */
export declare interface ReservationUnarchiveOptionalParams extends coreClient.OperationOptions {
}

/** Defines headers for Reservation_update operation. */
export declare interface ReservationUpdateHeaders {
    /** URL for checking the ongoing status of the operation. */
    azureAsyncOperation?: string;
    /** URL for determining when an operation has completed. Only use this value only when Azure-AsyncOperation isn't returned. */
    location?: string;
    /** Clients should wait for the Retry-After interval before polling again */
    retryAfter?: number;
}

/** Optional parameters. */
export declare interface ReservationUpdateOptionalParams extends coreClient.OperationOptions {
    /** Delay to wait until next poll, in milliseconds. */
    updateIntervalInMs?: number;
    /** A serialized poller which can be used to resume an existing paused Long-Running-Operation. */
    resumeFrom?: string;
}

/** Contains response data for the update operation. */
export declare type ReservationUpdateResponse = ReservationResponse;

/** The aggregate values of reservation utilization */
export declare interface ReservationUtilizationAggregates {
    /**
     * The grain of the aggregate
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly grain?: number;
    /**
     * The grain unit of the aggregate
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly grainUnit?: string;
    /**
     * The aggregate value
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly value?: number;
    /**
     * The aggregate value unit
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly valueUnit?: string;
}

/**
 * Defines values for ReservedResourceType. \
 * {@link KnownReservedResourceType} can be used interchangeably with ReservedResourceType,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **VirtualMachines** \
 * **SqlDatabases** \
 * **SuseLinux** \
 * **CosmosDb** \
 * **RedHat** \
 * **SqlDataWarehouse** \
 * **VMwareCloudSimple** \
 * **RedHatOsa** \
 * **Databricks** \
 * **AppService** \
 * **ManagedDisk** \
 * **BlockBlob** \
 * **RedisCache** \
 * **AzureDataExplorer** \
 * **MySql** \
 * **MariaDb** \
 * **PostgreSql** \
 * **DedicatedHost** \
 * **SapHana** \
 * **SqlAzureHybridBenefit** \
 * **AVS** \
 * **DataFactory** \
 * **NetAppStorage** \
 * **AzureFiles** \
 * **SqlEdge** \
 * **VirtualMachineSoftware**
 */
export declare type ReservedResourceType = string;

/** Common fields that are returned in the response for all Azure Resource Manager resources */
export declare interface Resource {
    /**
     * Fully qualified resource ID for the resource. E.g. "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}"
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly id?: string;
    /**
     * The name of the resource
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly name?: string;
    /**
     * The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly type?: string;
    /**
     * Azure Resource Manager metadata containing createdBy and modifiedBy information.
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly systemData?: SystemData;
}

/** Resource name provided by the resource provider. Use this property for quotaRequest parameter. */
export declare interface ResourceName {
    /** Resource name. */
    value?: string;
    /**
     * Resource display localized name.
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly localizedValue?: string;
}

/**
 * Defines values for ResourceType. \
 * {@link KnownResourceType} can be used interchangeably with ResourceType,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **standard** \
 * **dedicated** \
 * **lowPriority** \
 * **shared** \
 * **serviceSpecific**
 */
export declare type ResourceType = string;

/** Interface representing a Return. */
export declare interface Return {
    /**
     * Return a reservation and get refund information.
     * @param reservationOrderId Order Id of the reservation
     * @param body Information needed for returning reservation.
     * @param options The options parameters.
     */
    beginPost(reservationOrderId: string, body: RefundRequest, options?: ReturnPostOptionalParams): Promise<SimplePollerLike<OperationState<ReturnPostResponse>, ReturnPostResponse>>;
    /**
     * Return a reservation and get refund information.
     * @param reservationOrderId Order Id of the reservation
     * @param body Information needed for returning reservation.
     * @param options The options parameters.
     */
    beginPostAndWait(reservationOrderId: string, body: RefundRequest, options?: ReturnPostOptionalParams): Promise<ReturnPostResponse>;
}

/** Defines headers for Return_post operation. */
export declare interface ReturnPostHeaders {
    location?: string;
}

/** Optional parameters. */
export declare interface ReturnPostOptionalParams extends coreClient.OperationOptions {
    /** Delay to wait until next poll, in milliseconds. */
    updateIntervalInMs?: number;
    /** A serialized poller which can be used to resume an existing paused Long-Running-Operation. */
    resumeFrom?: string;
}

/** Contains response data for the post operation. */
export declare type ReturnPostResponse = ReservationOrderResponse;

/** Request body for savings plan purchase */
export declare interface SavingsPlanPurchaseRequest {
    /** The name of sku */
    sku?: SkuName;
    /** Friendly name of the savings plan */
    displayName?: string;
    /** Subscription that will be charged for purchasing reservation or savings plan */
    billingScopeId?: string;
    /** Represent savings plan term in ISO 8601 format. */
    term?: SavingsPlanTerm;
    /** Represents the billing plan in ISO 8601 format. Required only for monthly billing plans. */
    billingPlan?: BillingPlan;
    /** Type of the Applied Scope. */
    appliedScopeType?: AppliedScopeType;
    /** Properties specific to applied scope type. Not required if not applicable. Required and need to provide tenantId and managementGroupId if AppliedScopeType is ManagementGroup */
    appliedScopeProperties?: AppliedScopeProperties;
    /** Commitment towards the benefit. */
    commitment?: Commitment;
}

/**
 * Defines values for SavingsPlanTerm. \
 * {@link KnownSavingsPlanTerm} can be used interchangeably with SavingsPlanTerm,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **P1Y** \
 * **P3Y**
 */
export declare type SavingsPlanTerm = string;

/** Savings plan purchase details */
export declare interface SavingsPlanToPurchaseCalculateExchange {
    /** Request body for savings plan purchase */
    properties?: SavingsPlanPurchaseRequest;
    /** Pricing information containing the amount and the currency code */
    billingCurrencyTotal?: Price;
}

/** Savings plan purchase details */
export declare interface SavingsPlanToPurchaseExchange {
    /** Fully qualified id of the savings plan order being purchased */
    savingsPlanOrderId?: string;
    /** Fully qualified id of the savings plan being purchased. This value is only guaranteed to be non-null if the purchase is successful. */
    savingsPlanId?: string;
    /** Request body for savings plan purchase */
    properties?: SavingsPlanPurchaseRequest;
    /** Pricing information containing the amount and the currency code */
    billingCurrencyTotal?: Price;
    /** Status of the individual operation. */
    status?: OperationStatus;
}

/** The scope and whether it is valid. */
export declare interface ScopeProperties {
    scope?: string;
    valid?: boolean;
}

/** The API error details. */
export declare interface ServiceError {
    /** The error code. */
    code?: string;
    /** The error message text. */
    message?: string;
    /**
     * The list of error details.
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly details?: ServiceErrorDetail[];
}

/** The error details. */
export declare interface ServiceErrorDetail {
    /**
     * The error code.
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly code?: string;
    /**
     * The error message.
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly message?: string;
}

/** Capability of a sku. */
export declare interface SkuCapability {
    /** An invariant to describe the feature. */
    name?: string;
    /** An invariant if the feature is measured by quantity. */
    value?: string;
}

/** The name of sku */
export declare interface SkuName {
    name?: string;
}

/** Property of a sku. */
export declare interface SkuProperty {
    /** An invariant to describe the feature. */
    name?: string;
    /** An invariant if the feature is measured by quantity. */
    value?: string;
}

/** Restriction of a sku. */
export declare interface SkuRestriction {
    /** The type of restrictions. */
    type?: string;
    /** The value of restrictions. If the restriction type is set to location. This would be different locations where the sku is restricted. */
    values?: string[];
    /** The reason for restriction. */
    reasonCode?: string;
}

/** The request for reservation split */
export declare interface SplitRequest {
    /** List of the quantities in the new reservations to create. */
    quantities?: number[];
    /** Resource id of the reservation to be split. Format of the resource id should be /providers/Microsoft.Capacity/reservationOrders/{reservationOrderId}/reservations/{reservationId} */
    reservationId?: string;
}

/** The sub-request submitted with the quota request. */
export declare interface SubRequest {
    /**
     * Quota (resource limit).
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly limit?: number;
    /** The resource name. */
    name?: ResourceName;
    /**
     * Resource type for which the quota check was made.
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly resourceType?: string;
    /**  The limit units, such as **count** and **bytes**. Use the unit field provided in the response of the GET quota operation. */
    unit?: string;
    /** The quota request status. */
    provisioningState?: QuotaRequestState;
    /**
     * User-friendly status message.
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly message?: string;
    /**
     * Sub request ID for individual request.
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly subRequestId?: string;
}

/** The scopes checked by the available scope api. */
export declare interface SubscriptionScopeProperties {
    scopes?: ScopeProperties[];
}

/** Metadata pertaining to creation and last modification of the resource. */
export declare interface SystemData {
    /** The identity that created the resource. */
    createdBy?: string;
    /** The type of identity that created the resource. */
    createdByType?: CreatedByType;
    /** The timestamp of resource creation (UTC). */
    createdAt?: Date;
    /** The identity that last modified the resource. */
    lastModifiedBy?: string;
    /** The type of identity that last modified the resource. */
    lastModifiedByType?: CreatedByType;
    /** The timestamp of resource last modification (UTC) */
    lastModifiedAt?: Date;
}

/**
 * Defines values for UserFriendlyAppliedScopeType. \
 * {@link KnownUserFriendlyAppliedScopeType} can be used interchangeably with UserFriendlyAppliedScopeType,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **None** \
 * **Shared** \
 * **Single** \
 * **ResourceGroup** \
 * **ManagementGroup**
 */
export declare type UserFriendlyAppliedScopeType = string;

/**
 * Defines values for UserFriendlyRenewState. \
 * {@link KnownUserFriendlyRenewState} can be used interchangeably with UserFriendlyRenewState,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **On** \
 * **Off** \
 * **Renewed** \
 * **NotRenewed** \
 * **NotApplicable**
 */
export declare type UserFriendlyRenewState = string;

export { }
